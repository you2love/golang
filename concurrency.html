<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>并发 - Go 学习教程</title>
    <link rel="stylesheet" href="styles.css?v=1.3">
    <script src="scroll.js"></script>
    </head>
<body>
    <div class="container">
        <aside class="sidebar">
        <!-- 导航栏将通过JavaScript动态加载 -->
    </aside>
        <div class="content">
            <a href="index.html" class="back-link">← 返回首页</a>
            <h1>并发</h1>

            <h2 id="goroutine">Goroutine</h2>
            <p>Goroutine 是 Go 语言轻量级的线程实现，由 Go 运行时管理。</p>

            <pre><code><span class="keyword">package</span> main

<span class="keyword">import</span> (
    <span class="string">"fmt"</span>
    <span class="string">"time"</span>
)

<span class="function">func</span> <span class="function">say</span>(s <span class="keyword">string</span>) {
    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ {
        time.<span class="function">Sleep</span>(<span class="number">100</span> * time.Millisecond)
        fmt.<span class="function">Println</span>(s)
    }
}

<span class="function">func</span> <span class="function">main</span>() {
    <span class="comment">// 启动 goroutine</span>
    <span class="keyword">go</span> <span class="function">say</span>(<span class="string">"world"</span>)
    <span class="function">say</span>(<span class="string">"hello"</span>)
}</code></pre>

            <div class="note-box">
                <h3>Goroutine 内部实现原理</h3>
                <p><strong>1. Goroutine 的内部结构：</strong></p>
                <p>Goroutine 是 Go 运行时（runtime）管理的轻量级线程，其内部结构包含：</p>
                <pre><code><span class="comment">// Goroutine 的内部结构（简化版）</span>
<span class="keyword">type</span> g <span class="keyword">struct</span> {
    stack       stack   <span class="comment">// 栈内存</span>
    stackguard0 uintptr <span class="comment">// 栈溢出检查</span>
    m           *m      <span class="comment">// 关联的 M（Machine）</span>
    sched       gobuf   <span class="comment">// 调度信息</span>
    goid        int64   <span class="comment">// Goroutine ID</span>
    gopc        uintptr <span class="comment">// 创建该 goroutine 的 PC</span>
    startpc     uintptr <span class="comment">// goroutine 函数的起始 PC</span>
    atomicstatus uint32 <span class="comment">// 原子状态</span>
    goid        int64   <span class="comment">// Goroutine 唯一标识</span>
}</code></pre>

                <p><strong>2. M（Machine）结构：</strong></p>
                <p>M 代表操作系统线程，负责执行 goroutine：</p>
                <pre><code><span class="comment">// M 的内部结构（简化版）</span>
<span class="keyword">type</span> m <span class="keyword">struct</span> {
    g0      *g      <span class="comment">// 调度用的 goroutine</span>
    curg    *g      <span class="comment">// 当前运行的 goroutine</span>
    p       *p      <span class="comment">// 关联的 P（Processor）</span>
    nextp   *p      <span class="comment">// 下一个 P</span>
    id      int64   <span class="comment">// M 的 ID</span>
    spinning <span class="keyword">bool</span>   <span class="comment">// 是否在自旋寻找工作</span>
    blocked <span class="keyword">bool</span>   <span class="comment">// 是否阻塞</span>
}</code></pre>

                <p><strong>3. P（Processor）结构：</strong></p>
                <p>P 代表处理器，维护一个本地运行队列：</p>
                <pre><code><span class="comment">// P 的内部结构（简化版）</span>
<span class="keyword">type</span> p <span class="keyword">struct</span> {
    id          int32
    status      uint32
    link        *p
    schedtick   uint32
    syscalltick uint32
    m           *m      <span class="comment">// 关联的 M</span>
    mcache      *mcache <span class="comment">// 内存分配缓存</span>
    runqhead    uint32
    runqtail    uint32
    runq        [<span class="number">256</span>]<span class="keyword">guintptr</span> <span class="comment">// 本地运行队列</span>
    runnext     guintptr <span class="comment">// 下一个运行的 goroutine</span>
}</code></pre>

                <p><strong>4. GMP 调度模型：</strong></p>
                <pre><code><span class="keyword">package</span> main

<span class="keyword">import</span> (
    <span class="string">"fmt"</span>
    <span class="string">"runtime"</span>
    <span class="string">"sync"</span>
    <span class="string">"time"</span>
)

<span class="function">func</span> <span class="function">worker</span>(id <span class="keyword">int</span>, wg *sync.WaitGroup) {
    <span class="keyword">defer</span> wg.<span class="function">Done</span>()
    fmt.<span class="function">Printf</span>(<span class="string">"Worker %d 开始工作\n"</span>, id)
    time.<span class="function">Sleep</span>(<span class="number">100</span> * time.Millisecond)
    fmt.<span class="function">Printf</span>(<span class="string">"Worker %d 完成工作\n"</span>, id)
}

<span class="function">func</span> <span class="function">main</span>() {
    <span class="comment">// 设置使用的 P 数量</span>
    runtime.<span class="function">GOMAXPROCS</span>(<span class="number">4</span>)
    
    fmt.<span class="function">Printf</span>(<span class="string">"CPU 核心数: %d\n"</span>, runtime.<span class="function">NumCPU</span>())
    fmt.<span class="function">Printf</span>(<span class="string">"GOMAXPROCS: %d\n"</span>, runtime.<span class="function">GOMAXPROCS</span>(<span class="number">0</span>))
    
    <span class="keyword">var</span> wg sync.WaitGroup
    
    <span class="comment">// 启动多个 goroutine</span>
    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++ {
        wg.<span class="function">Add</span>(<span class="number">1</span>)
        <span class="keyword">go</span> <span class="function">worker</span>(i, &amp;wg)
    }
    
    wg.<span class="function">Wait</span>()
    fmt.<span class="function">Println</span>(<span class="string">"所有 worker 完成"</span>)
}</code></pre>

                <p><strong>5. Goroutine 调度过程：</strong></p>
                <pre><code><span class="keyword">package</span> main

<span class="keyword">import</span> (
    <span class="string">"fmt"</span>
    <span class="string">"runtime"</span>
)

<span class="function">func</span> <span class="function">task</span>(id <span class="keyword">int</span>) {
    fmt.<span class="function">Printf</span>(<span class="string">"Task %d 在 P%d 上运行\n"</span>, id, runtime.<span class="function">GOMAXPROCS</span>(<span class="number">0</span>))
}

<span class="function">func</span> <span class="function">main</span>() {
    <span class="comment">// Goroutine 调度过程：</span>
    <span class="comment">// 1. 创建 goroutine：go func() {}</span>
    <span class="comment">// 2. 将 goroutine 放入本地运行队列（P 的 runq）</span>
    <span class="comment">// 3. M 从 P 的 runq 中获取 goroutine 执行</span>
    <span class="comment">// 4. 如果 P 的 runq 为空，从全局队列或其他 P 窃取 goroutine</span>
    <span class="comment">// 5. Goroutine 执行完成或阻塞，M 继续执行下一个 goroutine</span>
    
    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++ {
        <span class="keyword">go</span> <span class="function">task</span>(i)
    }
    
    <span class="comment">// 等待 goroutine 完成</span>
    <span class="keyword">select</span> {}
}</code></pre>

                <p><strong>6. 工作窃取（Work Stealing）：</strong></p>
                <pre><code><span class="keyword">package</span> main

<span class="keyword">import</span> (
    <span class="string">"fmt"</span>
    <span class="string">"runtime"</span>
    <span class="string">"sync"</span>
    <span class="string">"time"</span>
)

<span class="function">func</span> <span class="function">heavyTask</span>(id <span class="keyword">int</span>, wg *sync.WaitGroup) {
    <span class="keyword">defer</span> wg.<span class="function">Done</span>()
    
    <span class="comment">// 模拟不同负载的任务</span>
    duration := time.Duration(<span class="number">50</span>+id*<span class="number">10</span>) * time.Millisecond
    time.<span class="function">Sleep</span>(duration)
    
    fmt.<span class="function">Printf</span>(<span class="string">"Task %d 完成，耗时 %v\n"</span>, id, duration)
}

<span class="function">func</span> <span class="function">main</span>() {
    runtime.<span class="function">GOMAXPROCS</span>(<span class="number">2</span>) <span class="comment">// 使用 2 个 P</span>
    
    <span class="keyword">var</span> wg sync.WaitGroup
    
    <span class="comment">// 创建不同负载的任务</span>
    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++ {
        wg.<span class="function">Add</span>(<span class="number">1</span>)
        <span class="keyword">go</span> <span class="function">heavyTask</span>(i, &amp;wg)
    }
    
    wg.<span class="function">Wait</span>()
    fmt.<span class="function">Println</span>(<span class="string">"所有任务完成"</span>)
    
    <span class="comment">// 工作窃取机制：</span>
    <span class="comment">// 1. P1 的任务较多，P2 的任务较少</span>
    <span class="comment">// 2. P2 完成自己的任务后，会从 P1 窃取任务执行</span>
    <span class="comment">// 3. 这实现了负载均衡，充分利用 CPU 资源</span>
}</code></pre>

                <p><strong>7. Goroutine 栈管理：</strong></p>
                <pre><code><span class="keyword">package</span> main

<span class="keyword">import</span> (
    <span class="string">"fmt"</span>
    <span class="string">"runtime"</span>
)

<span class="function">func</span> <span class="function">recursive</span>(depth <span class="keyword">int</span>) {
    <span class="keyword">var</span> buf [<span class="number">1024</span>]<span class="keyword">byte</span> <span class="comment">// 分配 1KB 栈空间</span>
    
    <span class="keyword">if</span> depth &lt; <span class="number">100</span> {
        fmt.<span class="function">Printf</span>(<span class="string">"递归深度: %d, 栈地址: %p\n"</span>, depth, &amp;buf)
        <span class="function">recursive</span>(depth + <span class="number">1</span>)
    }
}

<span class="function">func</span> <span class="function">main</span>() {
    fmt.<span class="function">Printf</span>(<span class="string">"初始栈大小: %d KB\n"</span>, runtime.<span class="function">GoroutineStack</span>()/<span class="number">1024</span>)
    
    <span class="comment">// Goroutine 栈管理特点：</span>
    <span class="comment">// 1. 初始栈大小：2KB（Go 1.4+）</span>
    <span class="comment">// 2. 动态增长：栈空间不足时自动扩容</span>
    <span class="comment">// 3. 最大栈大小：1GB（可配置）</span>
    <span class="comment">// 4. 栈拷贝：扩容时将旧栈内容拷贝到新栈</span>
    
    <span class="keyword">go</span> <span class="function">recursive</span>(<span class="number">0</span>)
    
    <span class="keyword">select</span> {}
}</code></pre>

                <p><strong>8. Goroutine 状态转换：</strong></p>
                <pre><code><span class="keyword">package</span> main

<span class="keyword">import</span> (
    <span class="string">"fmt"</span>
    <span class="string">"runtime"</span>
    <span class="string">"time"</span>
)

<span class="function">func</span> <span class="function">demonstrateStates</span>() {
    fmt.<span class="function">Println</span>(<span class="string">"Goroutine 状态转换："</span>)
    fmt.<span class="function">Println</span>(<span class="string">"_Gidle: 刚创建，未初始化"</span>)
    fmt.<span class="function">Println</span>(<span class="string">"_Grunnable: 在运行队列中，等待执行"</span>)
    fmt.<span class="function">Println</span>(<span class="string">"_Grunning: 正在执行"</span>)
    fmt.<span class="function">Println</span>(<span class="string">"_Gsyscall: 正在执行系统调用"</span>)
    fmt.<span class="function">Println</span>(<span class="string">"_Gwaiting: 等待（channel、sleep 等）"</span>)
    fmt.<span class="function">Println</span>(<span class="string">"_Gdead: 已退出"</span>)
}

<span class="function">func</span> <span class="function">main</span>() {
    <span class="keyword">go</span> <span class="function">demonstrateStates</span>()
    
    <span class="comment">// Goroutine 状态转换示例：</span>
    <span class="comment">// _Gidle -> _Grunnable: 创建 goroutine</span>
    <span class="comment">// _Grunnable -> _Grunning: 被调度执行</span>
    <span class="comment">// _Grunning -> _Gwaiting: 等待 channel 或 sleep</span>
    <span class="comment">// _Gwaiting -> _Grunnable: 唤醒后重新进入队列</span>
    <span class="comment">// _Grunning -> _Gdead: 执行完成</span>
    
    time.<span class="function">Sleep</span>(<span class="number">100</span> * time.Millisecond)
}</code></pre>
            </div>

            <div class="example-box">
                <h3>Goroutine 最佳实践</h3>
                <p><strong>1. 合理控制 Goroutine 数量：</strong></p>
                <pre><code><span class="keyword">package</span> main

<span class="keyword">import</span> (
    <span class="string">"fmt"</span>
    <span class="string">"runtime"</span>
    <span class="string">"sync"</span>
    <span class="string">"time"</span>
)

<span class="comment">// 使用 worker pool 模式限制 goroutine 数量</span>
<span class="keyword">type</span> WorkerPool <span class="keyword">struct</span> {
    tasks   <span class="keyword">chan</span> <span class="keyword">int</span>
    workers <span class="keyword">int</span>
    wg      sync.WaitGroup
}

<span class="function">func</span> <span class="function">NewWorkerPool</span>(workers <span class="keyword">int</span>) *WorkerPool {
    <span class="keyword">return</span> &amp;WorkerPool{
        tasks:   <span class="function">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">100</span>),
        workers: workers,
    }
}

<span class="function">func</span> (wp *WorkerPool) <span class="function">Start</span>() {
    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; wp.workers; i++ {
        wp.wg.<span class="function">Add</span>(<span class="number">1</span>)
        <span class="keyword">go</span> wp.<span class="function">worker</span>(i)
    }
}

<span class="function">func</span> (wp *WorkerPool) <span class="function">worker</span>(id <span class="keyword">int</span>) {
    <span class="keyword">defer</span> wp.wg.<span class="function">Done</span>()
    <span class="keyword">for</span> task := <span class="keyword">range</span> wp.tasks {
        fmt.<span class="function">Printf</span>(<span class="string">"Worker %d 处理任务 %d\n"</span>, id, task)
        time.<span class="function">Sleep</span>(<span class="number">100</span> * time.Millisecond)
    }
}

<span class="function">func</span> (wp *WorkerPool) <span class="function">Submit</span>(task <span class="keyword">int</span>) {
    wp.tasks &lt;- task
}

<span class="function">func</span> (wp *WorkerPool) <span class="function">Stop</span>() {
    <span class="keyword">close</span>(wp.tasks)
    wp.wg.<span class="function">Wait</span>()
}

<span class="function">func</span> <span class="function">main</span>() {
    pool := <span class="function">NewWorkerPool</span>(<span class="number">5</span>) <span class="comment">// 限制为 5 个 worker</span>
    pool.<span class="function">Start</span>()
    
    <span class="comment">// 提交 20 个任务</span>
    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++ {
        pool.<span class="function">Submit</span>(i)
    }
    
    pool.<span class="function">Stop</span>()
    fmt.<span class="function">Println</span>(<span class="string">"所有任务完成"</span>)
}</code></pre>

                <p><strong>2. 避免 Goroutine 泄露：</strong></p>
                <pre><code><span class="keyword">package</span> main

<span class="keyword">import</span> (
    <span class="string">"fmt"</span>
    <span class="string">"time"</span>
)

<span class="comment">// 错误示例：goroutine 泄露</span>
<span class="function">func</span> <span class="function">leak</span>() {
    ch := <span class="function">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)
    <span class="keyword">go</span> <span class="keyword">func</span>() {
        val := &lt;-ch <span class="comment">// 永远阻塞，goroutine 泄露</span>
        fmt.<span class="function">Println</span>(val)
    }()
}

<span class="comment">// 正确示例：使用 context 控制</span>
<span class="keyword">import</span> <span class="string">"context"</span>

<span class="function">func</span> <span class="function">noLeak</span>(ctx context.Context) {
    ch := <span class="function">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)
    <span class="keyword">go</span> <span class="keyword">func</span>() {
        <span class="keyword">select</span> {
        <span class="keyword">case</span> val := &lt;-ch:
            fmt.<span class="function">Println</span>(val)
        <span class="keyword">case</span> &lt;-ctx.<span class="function">Done</span>():
            fmt.<span class="function">Println</span>(<span class="string">"goroutine 被取消"</span>)
            <span class="keyword">return</span>
        }
    }()
}

<span class="function">func</span> <span class="function">main</span>() {
    ctx, cancel := context.<span class="function">WithTimeout</span>(context.<span class="function">Background</span>(), <span class="number">2</span>*time.Second)
    <span class="keyword">defer</span> cancel()
    
    <span class="function">noLeak</span>(ctx)
    time.<span class="function">Sleep</span>(<span class="number">3</span> * time.Second)
}</code></pre>

                <p><strong>3. 使用 WaitGroup 等待 Goroutine：</strong></p>
                <pre><code><span class="keyword">package</span> main

<span class="keyword">import</span> (
    <span class="string">"fmt"</span>
    <span class="string">"sync"</span>
)

<span class="function">func</span> <span class="function">worker</span>(id <span class="keyword">int</span>, wg *sync.WaitGroup) {
    <span class="keyword">defer</span> wg.<span class="function">Done</span>()
    fmt.<span class="function">Printf</span>(<span class="string">"Worker %d 完成\n"</span>, id)
}

<span class="function">func</span> <span class="function">main</span>() {
    <span class="keyword">var</span> wg sync.WaitGroup
    
    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++ {
        wg.<span class="function">Add</span>(<span class="number">1</span>)
        <span class="keyword">go</span> <span class="function">worker</span>(i, &amp;wg)
    }
    
    wg.<span class="function">Wait</span>()
    fmt.<span class="function">Println</span>(<span class="string">"所有 worker 完成"</span>)
}</code></pre>

                <p><strong>4. 使用 ErrGroup 处理错误：</strong></p>
                <pre><code><span class="keyword">package</span> main

<span class="keyword">import</span> (
    <span class="string">"errors"</span>
    <span class="string">"fmt"</span>
    <span class="string">"golang.org/x/sync/errgroup"</span>
)

<span class="function">func</span> <span class="function">task</span>(name <span class="keyword">string</span>, shouldFail <span class="keyword">bool</span>) <span class="keyword">error</span> {
    fmt.<span class="function">Printf</span>(<span class="string">"Task %s 开始\n"</span>, name)
    <span class="keyword">if</span> shouldFail {
        <span class="keyword">return</span> errors.<span class="function">New</span>(<span class="string">"task failed"</span>)
    }
    fmt.<span class="function">Printf</span>(<span class="string">"Task %s 完成\n"</span>, name)
    <span class="keyword">return</span> <span class="keyword">nil</span>
}

<span class="function">func</span> <span class="function">main</span>() {
    <span class="keyword">var</span> g errgroup.Group
    
    g.<span class="function">Go</span>(<span class="keyword">func</span>() <span class="keyword">error</span> {
        <span class="keyword">return</span> <span class="function">task</span>(<span class="string">"A"</span>, <span class="keyword">false</span>)
    })
    
    g.<span class="function">Go</span>(<span class="keyword">func</span>() <span class="keyword">error</span> {
        <span class="keyword">return</span> <span class="function">task</span>(<span class="string">"B"</span>, <span class="keyword">true</span>) <span class="comment">// 这个会失败</span>
    })
    
    g.<span class="function">Go</span>(<span class="keyword">func</span>() <span class="keyword">error</span> {
        <span class="keyword">return</span> <span class="function">task</span>(<span class="string">"C"</span>, <span class="keyword">false</span>)
    })
    
    <span class="keyword">if</span> err := g.<span class="function">Wait</span>(); err != <span class="keyword">nil</span> {
        fmt.<span class="function">Println</span>(<span class="string">"错误:"</span>, err)
    }
}</code></pre>

                <p><strong>5. 使用 Channel 进行通信：</strong></p>
                <pre><code><span class="keyword">package</span> main

<span class="keyword">import</span> (
    <span class="string">"fmt"</span>
    <span class="string">"time"</span>
)

<span class="function">func</span> <span class="function">producer</span>(ch <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>) {
    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++ {
        ch &lt;- i
        fmt.<span class="function">Printf</span>(<span class="string">"生产: %d\n"</span>, i)
        time.<span class="function">Sleep</span>(<span class="number">100</span> * time.Millisecond)
    }
    <span class="keyword">close</span>(ch)
}

<span class="function">func</span> <span class="function">consumer</span>(ch &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>) {
    <span class="keyword">for</span> val := <span class="keyword">range</span> ch {
        fmt.<span class="function">Printf</span>(<span class="string">"消费: %d\n"</span>, val)
        time.<span class="function">Sleep</span>(<span class="number">150</span> * time.Millisecond)
    }
}

<span class="function">func</span> <span class="function">main</span>() {
    ch := <span class="function">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)
    
    <span class="keyword">go</span> <span class="function">producer</span>(ch)
    <span class="keyword">go</span> <span class="function">consumer</span>(ch)
    
    time.<span class="function">Sleep</span>(<span class="number">2</span> * time.Second)
}</code></pre>

                <p><strong>6. 使用 Context 取消 Goroutine：</strong></p>
                <pre><code><span class="keyword">package</span> main

<span class="keyword">import</span> (
    <span class="string">"context"</span>
    <span class="string">"fmt"</span>
    <span class="string">"time"</span>
)

<span class="function">func</span> <span class="function">worker</span>(ctx context.Context, id <span class="keyword">int</span>) {
    <span class="keyword">for</span> {
        <span class="keyword">select</span> {
        <span class="keyword">case</span> &lt;-ctx.<span class="function">Done</span>():
            fmt.<span class="function">Printf</span>(<span class="string">"Worker %d 被取消\n"</span>, id)
            <span class="keyword">return</span>
        <span class="keyword">default</span>:
            fmt.<span class="function">Printf</span>(<span class="string">"Worker %d 工作中...\n"</span>, id)
            time.<span class="function">Sleep</span>(<span class="number">500</span> * time.Millisecond)
        }
    }
}

<span class="function">func</span> <span class="function">main</span>() {
    ctx, cancel := context.<span class="function">WithCancel</span>(context.<span class="function">Background</span>())
    
    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++ {
        <span class="keyword">go</span> <span class="function">worker</span>(ctx, i)
    }
    
    time.<span class="function">Sleep</span>(<span class="number">2</span> * time.Second)
    cancel() <span class="comment">// 取消所有 goroutine</span>
    
    time.<span class="function">Sleep</span>(<span class="number">1</span> * time.Second)
}</code></pre>

                <p><strong>7. 使用 Mutex 保护共享资源：</strong></p>
                <pre><code><span class="keyword">package</span> main

<span class="keyword">import</span> (
    <span class="string">"fmt"</span>
    <span class="string">"sync"</span>
)

<span class="keyword">type</span> Counter <span class="keyword">struct</span> {
    mu    sync.Mutex
    value <span class="keyword">int</span>
}

<span class="function">func</span> (c *Counter) <span class="function">Increment</span>() {
    c.mu.<span class="function">Lock</span>()
    <span class="keyword">defer</span> c.mu.<span class="function">Unlock</span>()
    c.value++
}

<span class="function">func</span> (c *Counter) <span class="function">Value</span>() <span class="keyword">int</span> {
    c.mu.<span class="function">Lock</span>()
    <span class="keyword">defer</span> c.mu.<span class="function">Unlock</span>()
    <span class="keyword">return</span> c.value
}

<span class="function">func</span> <span class="function">main</span>() {
    <span class="keyword">var</span> counter Counter
    <span class="keyword">var</span> wg sync.WaitGroup
    
    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ {
        wg.<span class="function">Add</span>(<span class="number">1</span>)
        <span class="keyword">go</span> <span class="keyword">func</span>() {
            <span class="keyword">defer</span> wg.<span class="function">Done</span>()
            counter.<span class="function">Increment</span>()
        }()
    }
    
    wg.<span class="function">Wait</span>()
    fmt.<span class="function">Printf</span>(<span class="string">"最终值: %d\n"</span>, counter.<span class="function">Value</span>())
}</code></pre>

                <p><strong>8. 性能优化技巧：</strong></p>
                <ul>
                    <li><strong>避免过度创建 goroutine</strong>：使用 worker pool 模式</li>
                    <li><strong>合理设置 GOMAXPROCS</strong>：根据 CPU 核心数调整</li>
                    <li><strong>使用缓冲 channel</strong>：减少阻塞</li>
                    <li><strong>避免锁竞争</strong>：尽量使用 channel 通信</li>
                    <li><strong>使用 sync.Pool</strong>：重用对象，减少 GC 压力</li>
                    <li><strong>监控 goroutine 数量</strong>：使用 runtime.NumGoroutine()</li>
                </ul>
                <pre><code><span class="keyword">package</span> main

<span class="keyword">import</span> (
    <span class="string">"fmt"</span>
    <span class="string">"runtime"</span>
    <span class="string">"sync"</span>
    <span class="string">"time"</span>
)

<span class="function">func</span> <span class="function">monitorGoroutines</span>() {
    ticker := time.<span class="function">NewTicker</span>(<span class="number">1</span> * time.Second)
    <span class="keyword">defer</span> ticker.<span class="function">Stop</span>()
    
    <span class="keyword">for</span> <span class="keyword">range</span> ticker.C {
        fmt.<span class="function">Printf</span>(<span class="string">"当前 goroutine 数量: %d\n"</span>, runtime.<span class="function">NumGoroutine</span>())
    }
}

<span class="function">func</span> <span class="function">main</span>() {
    <span class="keyword">go</span> <span class="function">monitorGoroutines</span>()
    
    <span class="keyword">var</span> wg sync.WaitGroup
    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ {
        wg.<span class="function">Add</span>(<span class="number">1</span>)
        <span class="keyword">go</span> <span class="keyword">func</span>() {
            <span class="keyword">defer</span> wg.<span class="function">Done</span>()
            time.<span class="function">Sleep</span>(<span class="number">2</span> * time.Second)
        }()
    }
    
    wg.<span class="function">Wait</span>()
    fmt.<span class="function">Println</span>(<span class="string">"所有 goroutine 完成"</span>)
}</code></pre>
            </div>

            <h2 id="channel">Channel</h2>
            <p>Channel 是 goroutine 之间通信的管道。</p>

            <pre><code><span class="keyword">package</span> main

<span class="keyword">import</span> <span class="string">"fmt"</span>

<span class="function">func</span> <span class="function">sum</span>(s []<span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>) {
    sum := <span class="number">0</span>
    <span class="keyword">for</span> _, v := <span class="keyword">range</span> s {
        sum += v
    }
    c &lt;- sum <span class="comment">// 将和发送到 channel</span>
}

<span class="function">func</span> <span class="function">main</span>() {
    s := []<span class="keyword">int</span>{<span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, -<span class="number">9</span>, <span class="number">4</span>, <span class="number">0</span>}

    c := <span class="function">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)
    <span class="keyword">go</span> <span class="function">sum</span>(s[:<span class="function">len</span>(s)/<span class="number">2</span>], c)
    <span class="keyword">go</span> <span class="function">sum</span>(s[<span class="function">len</span>(s)/<span class="number">2</span>:], c)
    x, y := &lt;-c, &lt;-c <span class="comment">// 从 channel 接收</span>

    fmt.<span class="function">Println</span>(x, y, x+y)
}</code></pre>

            <div class="note-box">
                <h3>Channel 内部实现原理</h3>
                
                <p><strong>1. Channel 的核心数据结构：</strong></p>
                <p>Channel 在 Go 运行时中的核心结构是 <code>hchan</code>：</p>
                <pre><code><span class="comment">// runtime/chan.go - Channel 的核心结构（简化版）</span>
<span class="keyword">type</span> hchan <span class="keyword">struct</span> {
    qcount   uint           <span class="comment">// 当前队列中元素个数</span>
    dataqsiz uint           <span class="comment">// 环形队列大小（容量）</span>
    buf      unsafe.Pointer <span class="comment">// 环形队列指针</span>
    elemsize uint16         <span class="comment">// 元素大小</span>
    closed   uint32         <span class="comment">// channel 是否关闭</span>
    elemtype *_type         <span class="comment">// 元素类型</span>
    sendx    uint           <span class="comment">// 发送索引</span>
    recvx    uint           <span class="comment">// 接收索引</span>
    recvq    waitq          <span class="comment">// 接收等待队列</span>
    sendq    waitq          <span class="comment">// 发送等待队列</span>
    lock     mutex          <span class="comment">// 互斥锁</span>
}</code></pre>

                <p><strong>2. 环形队列实现：</strong></p>
                <p>Channel 使用环形队列来存储数据，这是一个高效的循环缓冲区：</p>
                <pre><code><span class="comment">// 环形队列的工作原理示例</span>
<span class="comment">// 假设容量为 5 的 channel</span>

<span class="comment">// 初始状态: []</span>
<span class="comment">// sendx = 0, recvx = 0</span>

<span class="comment">// 发送 1, 2, 3: [1, 2, 3, _, _]</span>
<span class="comment">// sendx = 3, recvx = 0</span>

<span class="comment">// 接收 2 个值: [_, _, 3, _, _]</span>
<span class="comment">// sendx = 3, recvx = 2</span>

<span class="comment">// 继续发送 4, 5: [_, _, 3, 4, 5]</span>
<span class="comment">// sendx = 0, recvx = 2 (循环回到开头)</span>

<span class="comment">// 接收 3 个值: [_, _, _, _, _]</span>
<span class="comment">// sendx = 0, recvx = 0 (队列为空)</span></code></pre>

                <p><strong>3. 发送操作流程：</strong></p>
                <pre><code><span class="comment">// 发送操作: ch &lt;- value</span>

<span class="comment">// 步骤 1: 获取 channel 锁</span>
<span class="comment">// lock(&amp;c.lock)</span>

<span class="comment">// 步骤 2: 检查是否有接收者在等待</span>
<span class="keyword">if</span> sg := c.recvq.<span class="function">dequeue</span>(); sg != <span class="keyword">nil</span> {
    <span class="comment">// 直接传递数据给接收者，不经过缓冲区</span>
    <span class="function">send</span>(c, sg, ep)
    <span class="keyword">return</span>
}

<span class="comment">// 步骤 3: 如果缓冲区有空间，放入缓冲区</span>
<span class="keyword">if</span> c.qcount &lt; c.dataqsiz {
    <span class="comment">// 将数据放入环形队列</span>
    qp := <span class="function">chanbuf</span>(c, c.sendx)
    <span class="function">typedmemmove</span>(c.elemtype, qp, ep)
    c.sendx++
    <span class="keyword">if</span> c.sendx == c.dataqsiz {
        c.sendx = <span class="number">0</span>
    }
    c.qcount++
    <span class="keyword">return</span>
}

<span class="comment">// 步骤 4: 缓冲区已满，阻塞当前 goroutine</span>
<span class="comment">// 将当前 goroutine 加入发送等待队列</span>
<span class="comment">// gopark() - 让出 CPU，等待被唤醒</span></code></pre>

                <p><strong>4. 接收操作流程：</strong></p>
                <pre><code><span class="comment">// 接收操作: value := &lt;-ch</span>

<span class="comment">// 步骤 1: 获取 channel 锁</span>
<span class="comment">// lock(&amp;c.lock)</span>

<span class="comment">// 步骤 2: 检查是否有发送者在等待</span>
<span class="keyword">if</span> sg := c.sendq.<span class="function">dequeue</span>(); sg != <span class="keyword">nil</span> {
    <span class="comment">// 直接从发送者获取数据</span>
    <span class="function">recv</span>(c, sg, ep)
    <span class="keyword">return</span>
}

<span class="comment">// 步骤 3: 如果缓冲区有数据，从缓冲区读取</span>
<span class="keyword">if</span> c.qcount &gt; <span class="number">0</span> {
    qp := <span class="function">chanbuf</span>(c, c.recvx)
    <span class="keyword">if</span> ep != <span class="keyword">nil</span> {
        <span class="function">typedmemmove</span>(c.elemtype, ep, qp)
    }
    <span class="function">typedmemclr</span>(c.elemtype, qp)
    c.recvx++
    <span class="keyword">if</span> c.recvx == c.dataqsiz {
        c.recvx = <span class="number">0</span>
    }
    c.qcount--
    <span class="keyword">return</span>
}

<span class="comment">// 步骤 4: 缓冲区为空且未关闭，阻塞当前 goroutine</span>
<span class="comment">// 将当前 goroutine 加入接收等待队列</span>
<span class="comment">// gopark() - 让出 CPU，等待被唤醒</span></code></pre>

                <p><strong>5. 关闭操作流程：</strong></p>
                <pre><code><span class="comment">// 关闭操作: close(ch)</span>

<span class="comment">// 步骤 1: 获取 channel 锁</span>
<span class="comment">// lock(&amp;c.lock)</span>

<span class="comment">// 步骤 2: 标记 channel 为已关闭</span>
c.closed = <span class="number">1</span>

<span class="comment">// 步骤 3: 唤醒所有等待的接收者</span>
<span class="keyword">for</span> {
    sg := c.recvq.<span class="function">dequeue</span>()
    <span class="keyword">if</span> sg == <span class="keyword">nil</span> {
        <span class="keyword">break</span>
    }
    sg.elem = <span class="keyword">nil</span>  <span class="comment">// 接收者获得零值</span>
    <span class="function">goready</span>(sg.g)  <span class="comment">// 唤醒 goroutine</span>
}

<span class="comment">// 步骤 4: 唤醒所有等待的发送者（它们会 panic）</span>
<span class="keyword">for</span> {
    sg := c.sendq.<span class="function">dequeue</span>()
    <span class="keyword">if</span> sg == <span class="keyword">nil</span> {
        <span class="keyword">break</span>
    }
    sg.elem = <span class="keyword">nil</span>
    <span class="function">goready</span>(sg.g)  <span class="comment">// 唤醒后发送者会 panic</span>
}</code></pre>
            </div>

            <div class="example-box">
                <h3>Channel 最佳实践</h3>
                
                <p><strong>1. 选择合适的 Channel 类型：</strong></p>
                <pre><code><span class="keyword">package</span> main

<span class="keyword">import</span> <span class="string">"fmt"</span>

<span class="comment">// 无缓冲 Channel（同步）- 适用于需要同步的场景</span>
<span class="function">func</span> <span class="function">synchronousExample</span>() {
    ch := <span class="function">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)
    
    <span class="keyword">go</span> <span class="keyword">func</span>() {
        fmt.<span class="function">Println</span>(<span class="string">"发送者: 准备发送"</span>)
        ch &lt;- <span class="number">42</span>  <span class="comment">// 阻塞直到有消费者接收</span>
        fmt.<span class="function">Println</span>(<span class="string">"发送者: 数据已发送"</span>)
    }()
    
    fmt.<span class="Function">Println</span>(<span class="string">"接收者: 等待数据"</span>)
    val := &lt;-ch
    fmt.<span class="function">Printf</span>(<span class="string">"接收者: 收到 %d\n"</span>, val)
}

<span class="comment">// 缓冲 Channel（异步）- 适用于生产者和消费者速度不匹配</span>
<span class="function">func</span> <span class="function">bufferedExample</span>() {
    ch := <span class="function">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)  <span class="comment">// 缓冲大小为 3</span>
    
    <span class="comment">// 可以发送 3 个数据而不会阻塞</span>
    ch &lt;- <span class="number">1</span>
    ch &lt;- <span class="number">2</span>
    ch &lt;- <span class="number">3</span>
    fmt.<span class="function">Println</span>(<span class="string">"已发送 3 个数据"</span>)
    
    fmt.<span class="function">Println</span>(&lt;-ch)
    fmt.<span class="function">Println</span>(&lt;-ch)
    fmt.<span class="function">Println</span>(&lt;-ch)
}</code></pre>

                <p><strong>2. 避免 Goroutine 泄露：</strong></p>
                <pre><code><span class="keyword">package</span> main

<span class="keyword">import</span> (
    <span class="string">"context"</span>
    <span class="string">"fmt"</span>
    <span class="string">"time"</span>
)

<span class="comment">// 错误示例：goroutine 泄露</span>
<span class="function">func</span> <span class="function">leakExample</span>() {
    ch := <span class="function">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)
    <span class="keyword">go</span> <span class="keyword">func</span>() {
        val := &lt;-ch  <span class="comment">// 永远阻塞，goroutine 泄露</span>
        fmt.<span class="function">Println</span>(val)
    }()
    <span class="comment">// 如果 ch 永远不发送数据，goroutine 永不退出</span>
}

<span class="comment">// 正确示例：使用 context 控制</span>
<span class="function">func</span> <span class="function">noLeakExample</span>() {
    ctx, cancel := context.<span class="function">WithTimeout</span>(context.<span class="function">Background</span>(), <span class="number">2</span>*time.Second)
    <span class="keyword">defer</span> cancel()
    
    ch := <span class="function">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)
    <span class="keyword">go</span> <span class="keyword">func</span>() {
        <span class="keyword">select</span> {
        <span class="keyword">case</span> val := &lt;-ch:
            fmt.<span class="function">Println</span>(val)
        <span class="keyword">case</span> &lt;-ctx.<span class="function">Done</span>():
            fmt.<span class="function">Println</span>(<span class="string">"goroutine 被取消"</span>)
            <span class="keyword">return</span>
        }
    }()
}</code></pre>

                <p><strong>3. 正确关闭 Channel：</strong></p>
                <pre><code><span class="keyword">package</span> main

<span class="keyword">import</span> <span class="string">"fmt"</span>

<span class="comment">// 原则：只在发送方关闭 channel，不要在接收方关闭</span>
<span class="function">func</span> <span class="function">producer</span>(ch <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>) {
    <span class="keyword">defer</span> <span class="keyword">close</span>(ch)  <span class="comment">// 发送完成后关闭</span>
    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ {
        ch &lt;- i
    }
}

<span class="function">func</span> <span class="function">consumer</span>(ch &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>) {
    <span class="keyword">for</span> v := <span class="keyword">range</span> ch {  <span class="comment">// 自动检测 channel 关闭</span>
        fmt.<span class="function">Println</span>(v)
    }
    fmt.<span class="function">Println</span>(<span class="string">"channel 已关闭"</span>)
}

<span class="comment">// 使用方向性 channel</span>
<span class="function">func</span> <span class="function">directionalExample</span>() {
    ch := <span class="function">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)
    <span class="keyword">go</span> <span class="function">producer</span>(ch)
    <span class="function">consumer</span>(ch)
}</code></pre>

                <p><strong>4. 处理 Channel 关闭后的零值：</strong></p>
                <pre><code><span class="keyword">package</span> main

<span class="keyword">import</span> <span class="string">"fmt"</span>

<span class="function">func</span> <span class="function">safeReceive</span>(ch &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>) (int, bool) {
    v, ok := &lt;-ch
    <span class="keyword">if</span> !ok {
        <span class="comment">// channel 已关闭，v 是零值</span>
        fmt.<span class="function">Println</span>(<span class="string">"channel 已关闭"</span>)
        <span class="keyword">return</span> <span class="number">0</span>, <span class="keyword">false</span>
    }
    <span class="keyword">return</span> v, <span class="keyword">true</span>
}</code></pre>

                <p><strong>5. 使用 Select 实现超时：</strong></p>
                <pre><code><span class="keyword">package</span> main

<span class="keyword">import</span> (
    <span class="string">"fmt"</span>
    <span class="string">"time"</span>
)

<span class="function">func</span> <span class="function">workerWithTimeout</span>(ch &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>, timeout time.Duration) {
    <span class="keyword">select</span> {
    <span class="keyword">case</span> v := &lt;-ch:
        fmt.<span class="function">Printf</span>(<span class="string">"收到: %d\n"</span>, v)
    <span class="keyword">case</span> &lt;-time.<span class="function">After</span>(timeout):
        fmt.<span class="function">Println</span>(<span class="string">"超时"</span>)
    }
}</code></pre>

                <p><strong>6. 扇出模式（Fan-out）：</strong></p>
                <pre><code><span class="keyword">package</span> main

<span class="keyword">import</span> <span class="string">"fmt"</span>

<span class="function">func</span> <span class="function">worker</span>(id <span class="keyword">int</span>, input &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>, output <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>) {
    <span class="keyword">defer</span> <span class="keyword">close</span>(output)
    <span class="keyword">for</span> v := <span class="keyword">range</span> input {
        result := v * <span class="number">2</span>  <span class="comment">// 处理数据</span>
        output &lt;- result
        fmt.<span class="function">Printf</span>(<span class="string">"Worker %d 处理: %d -> %d\n"</span>, id, v, result)
    }
}

<span class="function">func</span> <span class="function">fanOut</span>(input &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>, numWorkers <span class="keyword">int</span>) []&lt;-<span class="keyword">chan</span> <span class="keyword">int</span> {
    outputs := <span class="function">make</span>([]&lt;-<span class="keyword">chan</span> <span class="keyword">int</span>, numWorkers)
    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numWorkers; i++ {
        outputs[i] = <span class="function">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)
        <span class="keyword">go</span> <span class="function">worker</span>(i, input, outputs[i])
    }
    <span class="keyword">return</span> outputs
}</code></pre>

                <p><strong>7. 扇入模式（Fan-in）：</strong></p>
                <pre><code><span class="keyword">package</span> main

<span class="keyword">import</span> (
    <span class="string">"sync"</span>
)

<span class="function">func</span> <span class="function">fanIn</span>(inputs ...&lt;-<span class="keyword">chan</span> <span class="keyword">int</span>) &lt;-<span class="keyword">chan</span> <span class="keyword">int</span> {
    output := <span class="function">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)
    <span class="keyword">var</span> wg sync.WaitGroup
    
    <span class="keyword">for</span> _, input := <span class="keyword">range</span> inputs {
        wg.<span class="function">Add</span>(<span class="number">1</span>)
        <span class="keyword">go</span> <span class="keyword">func</span>(ch &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>) {
            <span class="keyword">defer</span> wg.<span class="function">Done</span>()
            <span class="keyword">for</span> v := <span class="keyword">range</span> ch {
                output &lt;- v
            }
        }(input)
    }
    
    <span class="keyword">go</span> <span class="keyword">func</span>() {
        wg.<span class="function">Wait</span>()
        <span class="keyword">close</span>(output)
    }()
    
    <span class="keyword">return</span> output
}</code></pre>

                <p><strong>8. 使用 Channel 实现信号量：</strong></p>
                <pre><code><span class="keyword">package</span> main

<span class="keyword">import</span> <span class="string">"fmt"</span>

<span class="comment">// 限制并发数</span>
<span class="function">func</span> <span class="function">semaphore</span>(maxConcurrent <span class="keyword">int</span>) {
    sem := <span class="function">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>{}, maxConcurrent)
    
    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ {
        sem &lt;- <span class="keyword">struct</span>{}{}  <span class="comment">// 获取信号量</span>
        <span class="keyword">go</span> <span class="keyword">func</span>(id <span class="keyword">int</span>) {
            <span class="keyword">defer</span> <span class="keyword">func</span>() { &lt;-sem }()  <span class="comment">// 释放信号量</span>
            <span class="function">doWork</span>(id)
        }(i)
    }
}

<span class="function">func</span> <span class="function">doWork</span>(id <span class="keyword">int</span>) {
    fmt.<span class="function">Printf</span>(<span class="string">"Task %d 开始\n"</span>, id)
}</code></pre>

                <p><strong>9. Channel 性能优化技巧：</strong></p>
                <ul>
                    <li><strong>预分配缓冲区</strong>：根据实际情况调整缓冲大小</li>
                    <li><strong>避免频繁创建和销毁 channel</strong>：重用 channel</li>
                    <li><strong>使用指针传递大对象</strong>：减少拷贝开销</li>
                    <li><strong>批量处理数据</strong>：减少 channel 操作次数</li>
                </ul>
                <pre><code><span class="keyword">package</span> main

<span class="keyword">type</span> LargeData <span class="keyword">struct</span> {
    <span class="comment">// 大量字段</span>
}

<span class="comment">// 传递指针而不是值</span>
<span class="function">func</span> <span class="function">pointerChannel</span>() {
    ch := <span class="function">make</span>(<span class="keyword">chan</span> *LargeData, <span class="number">100</span>)
    
    data := &amp;LargeData{}
    ch &lt;- data  <span class="comment">// 只传递指针</span>
}

<span class="comment">// 批量处理</span>
<span class="function">func</span> <span class="function">batchProcess</span>(ch &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>, batchSize <span class="keyword">int</span>) {
    batch := <span class="function">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, batchSize)
    <span class="keyword">for</span> v := <span class="keyword">range</span> ch {
        batch = <span class="function">append</span>(batch, v)
        <span class="keyword">if</span> <span class="function">len</span>(batch) &gt;= batchSize {
            <span class="function">processBatch</span>(batch)
            batch = batch[:<span class="number">0</span>]
        }
    }
    <span class="keyword">if</span> <span class="function">len</span>(batch) &gt; <span class="number">0</span> {
        <span class="function">processBatch</span>(batch)
    }
}</code></pre>

                <p><strong>10. Channel 错误处理：</strong></p>
                <pre><code><span class="keyword">package</span> main

<span class="keyword">import</span> (
    <span class="string">"fmt"</span>
    <span class="string">"time"</span>
)

<span class="function">func</span> <span class="function">safeChannelOperations</span>() {
    ch := <span class="function">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)
    
    <span class="keyword">go</span> <span class="keyword">func</span>() {
        <span class="keyword">defer</span> <span class="keyword">close</span>(ch)
        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ {
            ch &lt;- i
        }
    }()
    
    <span class="keyword">for</span> {
        <span class="keyword">select</span> {
        <span class="keyword">case</span> v, ok := &lt;-ch:
            <span class="keyword">if</span> !ok {
                fmt.<span class="function">Println</span>(<span class="string">"Channel 已关闭"</span>)
                <span class="keyword">return</span>
            }
            fmt.<span class="function">Printf</span>(<span class="string">"收到: %d\n"</span>, v)
        <span class="keyword">case</span> &lt;-time.<span class="function">After</span>(<span class="number">1</span> * time.Second):
            fmt.<span class="function">Println</span>(<span class="string">"超时"</span>)
            <span class="keyword">return</span>
        }
    }
}</code></pre>

                <p><strong>总结：</strong></p>
                <ul>
                    <li><strong>内部原理要点</strong>：环形队列、等待队列、直接传递、锁保护</li>
                    <li><strong>最佳实践要点</strong>：正确关闭、避免泄露、使用方向性、扇出扇入模式</li>
                    <li><strong>性能优化</strong>：合理缓冲、批量处理、指针传递、重用 channel</li>
                </ul>
            </div>

            <h2 id="buffered">Buffered Channel</h2>
            <pre><code><span class="keyword">package</span> main

<span class="keyword">import</span> <span class="string">"fmt"</span>

<span class="function">func</span> <span class="function">main</span>() {
    <span class="comment">// 创建带缓冲的 channel</span>
    ch := <span class="function">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">2</span>)

    ch &lt;- <span class="number">1</span>
    ch &lt;- <span class="number">2</span>

    fmt.<span class="function">Println</span>(&lt;-ch)
    fmt.<span class="function">Println</span>(&lt;-ch)
}</code></pre>

            <h2 id="range">Range 和 Close</h2>
            <pre><code><span class="keyword">package</span> main

<span class="keyword">import</span> <span class="string">"fmt"</span>

<span class="function">func</span> <span class="function">fibonacci</span>(n <span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>) {
    x, y := <span class="number">0</span>, <span class="number">1</span>
    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ {
        c &lt;- x
        x, y = y, x+y
    }
    <span class="keyword">close</span>(c) <span class="comment">// 关闭 channel</span>
}

<span class="function">func</span> <span class="function">main</span>() {
    c := <span class="function">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)
    <span class="keyword">go</span> <span class="function">fibonacci</span>(<span class="number">cap</span>(c), c)

    <span class="comment">// range 会持续从 channel 接收，直到 channel 被关闭</span>
    <span class="keyword">for</span> i := <span class="keyword">range</span> c {
        fmt.<span class="function">Println</span>(i)
    }
}</code></pre>

            <h2 id="select">Select</h2>
            <p>Select 语句让 goroutine 可以等待多个通信操作。</p>

            <pre><code><span class="keyword">package</span> main

<span class="keyword">import</span> <span class="string">"fmt"</span>

<span class="function">func</span> <span class="function">fibonacci</span>(c, quit <span class="keyword">chan</span> <span class="keyword">int</span>) {
    x, y := <span class="number">0</span>, <span class="number">1</span>
    <span class="keyword">for</span> {
        <span class="keyword">select</span> {
        <span class="keyword">case</span> c &lt;- x:
            x, y = y, x+y
        <span class="keyword">case</span> &lt;-quit:
            fmt.<span class="function">Println</span>(<span class="string">"quit"</span>)
            <span class="keyword">return</span>
        }
    }
}

<span class="function">func</span> <span class="function">main</span>() {
    c := <span class="function">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)
    quit := <span class="function">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)

    <span class="keyword">go</span> <span class="function">func</span>() {
        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ {
            fmt.<span class="function">Println</span>(&lt;-c)
        }
        quit &lt;- <span class="number">0</span>
    }()

    <span class="function">fibonacci</span>(c, quit)
}</code></pre>

            <h2 id="default">默认选择</h2>
            <pre><code><span class="keyword">package</span> main

<span class="keyword">import</span> (
    <span class="string">"fmt"</span>
    <span class="string">"time"</span>
)

<span class="function">func</span> <span class="function">main</span>() {
    tick := time.<span class="function">Tick</span>(<span class="number">100</span> * time.Millisecond)
    boom := time.<span class="function">After</span>(<span class="number">500</span> * time.Millisecond)

    <span class="keyword">for</span> {
        <span class="keyword">select</span> {
        <span class="keyword">case</span> &lt;-tick:
            fmt.<span class="function">Println</span>(<span class="string">"tick."</span>)
        <span class="keyword">case</span> &lt;-boom:
            fmt.<span class="function">Println</span>(<span class="string">"BOOM!"</span>)
            <span class="keyword">return</span>
        <span class="keyword">default</span>:
            fmt.<span class="function">Println</span>(<span class="string">"    ."</span>)
            time.<span class="function">Sleep</span>(<span class="number">50</span> * time.Millisecond)
        }
    }
}</code></pre>

            <h2 id="mutex">互斥锁（Mutex）</h2>
            <pre><code><span class="keyword">package</span> main

<span class="keyword">import</span> (
    <span class="string">"fmt"</span>
    <span class="string">"sync"</span>
    <span class="string">"time"</span>
)

<span class="comment">// SafeCounter 是并发安全的计数器</span>
<span class="keyword">type</span> SafeCounter <span class="keyword">struct</span> {
    mu sync.Mutex
    v  <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>
}

<span class="function">func</span> (c *SafeCounter) <span class="function">Inc</span>(key <span class="keyword">string</span>) {
    c.mu.<span class="function">Lock</span>()
    <span class="comment">// Lock 之后同一时刻只有一个 goroutine 能访问 c.v</span>
    c.v[key]++
    c.mu.<span class="function">Unlock</span>()
}

<span class="function">func</span> (c *SafeCounter) <span class="function">Value</span>(key <span class="keyword">string</span>) <span class="keyword">int</span> {
    c.mu.<span class="function">Lock</span>()
    <span class="comment">// Lock 之后同一时刻只有一个 goroutine 能访问 c.v</span>
    <span class="keyword">defer</span> c.mu.<span class="function">Unlock</span>()
    <span class="keyword">return</span> c.v[key]
}

<span class="function">func</span> <span class="function">main</span>() {
    c := SafeCounter{v: <span class="function">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)}

    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ {
        <span class="keyword">go</span> c.<span class="function">Inc</span>(<span class="string">"somekey"</span>)
    }

    time.<span class="function">Sleep</span>(time.Second)
    fmt.<span class="function">Println</span>(c.<span class="function">Value</span>(<span class="string">"somekey"</span>))
}</code></pre>

            <h2 id="waitgroup">WaitGroup</h2>
            <pre><code><span class="keyword">package</span> main

<span class="keyword">import</span> (
    <span class="string">"fmt"</span>
    <span class="string">"sync"</span>
    <span class="string">"time"</span>
)

<span class="function">func</span> <span class="function">worker</span>(id <span class="keyword">int</span>, wg *sync.WaitGroup) {
    <span class="keyword">defer</span> wg.<span class="function">Done</span>()

    fmt.<span class="function">Printf</span>(<span class="string">"Worker %d 开始工作\n"</span>, id)
    time.<span class="function">Sleep</span>(time.Second)
    fmt.<span class="function">Printf</span>(<span class="string">"Worker %d 完成工作\n"</span>, id)
}

<span class="function">func</span> <span class="function">main</span>() {
    <span class="keyword">var</span> wg sync.WaitGroup

    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++ {
        wg.<span class="function">Add</span>(<span class="number">1</span>)
        <span class="keyword">go</span> <span class="function">worker</span>(i, &amp;wg)
    }

    wg.<span class="function">Wait</span>()
    fmt.<span class="function">Println</span>(<span class="string">"所有 worker 完成"</span>)
}</code></pre>

            <h2 id="context">Context</h2>
            <pre><code><span class="keyword">package</span> main

<span class="keyword">import</span> (
    <span class="string">"context"</span>
    <span class="string">"fmt"</span>
    <span class="string">"time"</span>
)

<span class="function">func</span> <span class="function">main</span>() {
    <span class="comment">// 创建一个可取消的 context</span>
    ctx, cancel := context.<span class="function">WithCancel</span>(context.<span class="function">Background</span>())

    <span class="keyword">go</span> <span class="function">func</span>() {
        <span class="keyword">for</span> {
            <span class="keyword">select</span> {
            <span class="keyword">case</span> &lt;-ctx.<span class="function">Done</span>():
                fmt.<span class="function">Println</span>(<span class="string">"goroutine 被取消"</span>)
                <span class="keyword">return</span>
            <span class="keyword">default</span>:
                fmt.<span class="function">Println</span>(<span class="string">"goroutine 运行中"</span>)
                time.<span class="function">Sleep</span>(<span class="number">500</span> * time.Millisecond)
            }
        }
    }()

    time.<span class="function">Sleep</span>(<span class="number">2</span> * time.Second)
    fmt.<span class="function">Println</span>(<span class="string">"取消 goroutine"</span>)
    <span class="function">cancel</span>()
    time.<span class="function">Sleep</span>(time.Second)
}</code></pre>

            <h2 id="timeout">超时控制</h2>
            <pre><code><span class="keyword">package</span> main

<span class="keyword">import</span> (
    <span class="string">"context"</span>
    <span class="string">"fmt"</span>
    <span class="string">"time"</span>
)

<span class="function">func</span> <span class="function">longRunningTask</span>(ctx context.Context) {
    <span class="keyword">select</span> {
    <span class="keyword">case</span> &lt;-time.<span class="function">After</span>(<span class="number">5</span> * time.Second):
        fmt.<span class="function">Println</span>(<span class="string">"任务完成"</span>)
    <span class="keyword">case</span> &lt;-ctx.<span class="function">Done</span>():
        fmt.<span class="function">Println</span>(<span class="string">"任务超时:"</span>, ctx.<span class="function">Err</span>())
    }
}

<span class="function">func</span> <span class="function">main</span>() {
    <span class="comment">// 设置 2 秒超时</span>
    ctx, cancel := context.<span class="function">WithTimeout</span>(context.<span class="function">Background</span>(), <span class="number">2</span>*time.Second)
    <span class="keyword">defer</span> <span class="function">cancel</span>()

    <span class="function">longRunningTask</span>(ctx)
}</code></pre>
        </div>
    </div>
</body>
    <script src="navigation.js"></script>
</html>