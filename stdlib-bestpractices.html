<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>最佳实践 - Go 学习教程</title>
    <link rel="stylesheet" href="styles.css?v=1.3">
    <script src="navigation.js"></script>
</head>
<body>
    <div class="container">
        <aside class="sidebar">
        <!-- 导航栏将通过JavaScript动态加载 -->
    </aside>
                <div class="content">
            <a href="stdlib.html" class="back-link">← 返回 stdlib</a>
            <h2 id="bestpractices">最佳实践</h2>

            <div class="example-box">
                <h3>regexp 最佳实践</h3>
                <pre><code><span class="keyword">package</span> main

<span class="keyword">import</span> (
    <span class="string">"regexp"</span>
    <span class="string">"sync"</span>
)

<span class="comment">// 1. 预编译正则表达式</span>
<span class="keyword">var</span> (
    emailRe     = regexp.<span class="function">MustCompile</span>(<span class="string">`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`</span>)
    phoneRe     = regexp.<span class="function">MustCompile</span>(<span class="string">`^1[3-9]\d{9}$`</span>)
    reCache     = <span class="function">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*regexp.Regexp)
    reCacheMu   sync.RWMutex
)

<span class="comment">// 2. 缓存正则表达式</span>
<span class="function">func</span> <span class="function">GetRegex</span>(pattern <span class="keyword">string</span>) (*regexp.Regexp, <span class="keyword">error</span>) {
    reCacheMu.<span class="function">RLock</span>()
    re, ok := reCache[pattern]
    reCacheMu.<span class="function">RUnlock</span>()
    
    <span class="keyword">if</span> ok {
        <span class="keyword">return</span> re, <span class="keyword">nil</span>
    }
    
    re, err := regexp.<span class="function">Compile</span>(pattern)
    <span class="keyword">if</span> err != <span class="keyword">nil</span> {
        <span class="keyword">return</span> <span class="keyword">nil</span>, err
    }
    
    reCacheMu.<span class="function">Lock</span>()
    reCache[pattern] = re
    reCacheMu.<span class="function">Unlock</span>()
    
    <span class="keyword">return</span> re, <span class="keyword">nil</span>
}

<span class="comment">// 3. 使用原始字符串避免转义</span>
<span class="comment">// 好：`\d+`</span>
<span class="comment">// 坏："\d+"</span>

<span class="comment">// 4. 避免贪婪匹配</span>
<span class="comment">// 好：`<.*?>`</span>
<span class="comment">// 坏：`<.*>`</span>

<span class="comment">// 5. 使用非捕获组</span>
<span class="comment">// 好：`(?:a|b)c`</span>
<span class="comment">// 坏：`(a|b)c`</span></code></pre>

                <h3>sync 最佳实践</h3>
                <pre><code><span class="keyword">package</span> main

<span class="keyword">import</span> (
    <span class="string">"sync"</span>
)

<span class="comment">// 1. 避免锁的嵌套</span>
<span class="keyword">type</span> SafeCounter <span class="keyword">struct</span> {
    mu    sync.Mutex
    value <span class="keyword">int</span>
}

<span class="function">func</span> (c *SafeCounter) <span class="function">Increment</span>() {
    c.mu.<span class="function">Lock</span>()
    <span class="keyword">defer</span> c.mu.<span class="function">Unlock</span>()
    c.value++
}

<span class="comment">// 2. 使用 defer 确保锁释放</span>
<span class="function">func</span> (c *SafeCounter) <span class="function">Get</span>() <span class="keyword">int</span> {
    c.mu.<span class="function">Lock</span>()
    <span class="keyword">defer</span> c.mu.<span class="function">Unlock</span>()
    <span class="keyword">return</span> c.value
}

<span class="comment">// 3. 读写锁用于读多写少场景</span>
<span class="keyword">type</span> SafeMap <span class="keyword">struct</span> {
    mu   sync.RWMutex
    data <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>
}

<span class="function">func</span> (m *SafeMap) <span class="function">Get</span>(key <span class="keyword">string</span>) (<span class="keyword">string</span>, <span class="keyword">bool</span>) {
    m.mu.<span class="function">RLock</span>()
    <span class="keyword">defer</span> m.mu.<span class="function">RUnlock</span>()
    val, ok := m.data[key]
    <span class="keyword">return</span> val, ok
}

<span class="function">func</span> (m *SafeMap) <span class="function">Set</span>(key, value <span class="keyword">string</span>) {
    m.mu.<span class="function">Lock</span>()
    <span class="keyword">defer</span> m.mu.<span class="function">Unlock</span>()
    m.data[key] = value
}

<span class="comment">// 4. 使用 sync.Pool 重用对象</span>
<span class="keyword">var</span> bufferPool = sync.<span class="function">Pool</span>{
    New: <span class="keyword">func</span>() <span class="keyword">interface</span>{} {
        <span class="keyword">return</span> <span class="function">make</span>([]<span class="keyword">byte</span>, <span class="number">0</span>, <span class="number">1024</span>)
    },
}

<span class="function">func</span> <span class="function">getBuffer</span>() []<span class="keyword">byte</span> {
    <span class="keyword">return</span> bufferPool.<span class="function">Get</span>().([]<span class="keyword">byte</span>)
}

<span class="function">func</span> <span class="function">putBuffer</span>(buf []<span class="keyword">byte</span>) {
    bufferPool.<span class="function">Put</span>(buf[:<span class="number">0</span>])
}

<span class="comment">// 5. 使用 sync.Map 替代 map+Mutex（特定场景）</span>
<span class="comment">// 适用于：读多写少、键值对稳定</span></code></pre>

                <h3>json 最佳实践</h3>
                <pre><code><span class="keyword">package</span> main

<span class="keyword">import</span> (
    <span class="string">"encoding/json"</span>
)

<span class="comment">// 1. 使用结构体标签</span>
<span class="keyword">type</span> User <span class="keyword">struct</span> {
    Name     <span class="keyword">string</span> <span class="string">`json:"name"`</span>
    Age      <span class="keyword">int</span>    <span class="string">`json:"age"`</span>
    Password <span class="keyword">string</span> <span class="string">json:"-"`</span>           <span class="comment">// 忽略</span>
    Email    <span class="keyword">string</span> <span class="string">`json:"email,omitempty"`</span> <span class="comment">// 空值忽略</span>
}

<span class="comment">// 2. 使用指针处理可选字段</span>
<span class="keyword">type</span> Config <span class="keyword">struct</span> {
    Timeout *<span class="keyword">int</span>  <span class="string">`json:"timeout,omitempty"`</span>
    Enabled *<span class="keyword">bool</span> <span class="string">`json:"enabled,omitempty"`</span>
}

<span class="comment">// 3. 使用 json.RawMessage 延迟解析</span>
<span class="keyword">type</span> Message <span class="keyword">struct</span> {
    Type    <span class="keyword">string</span>          <span class="string">`json:"type"`</span>
    Payload json.RawMessage <span class="string">`json:"payload"`</span>
}

<span class="comment">// 4. 使用 json.Number 处理大数字</span>
<span class="keyword">type</span> Data <span class="keyword">struct</span> {
    ID json.Number <span class="string">`json:"id"`</span>
}

<span class="comment">// 5. 验证 JSON 结构</span>
<span class="function">func</span> <span class="function">validateJSON</span>(data []<span class="keyword">byte</span>) <span class="keyword">bool</span> {
    <span class="keyword">var</span> v <span class="keyword">interface</span>{
    <span class="keyword">return</span> json.<span class="function">Valid</span>(data)
}

<span class="comment">// 6. 使用 json.Encoder/Decoder 处理流</span>
<span class="comment">// 适用于大文件或网络流</span>

<span class="comment">// 7. 处理自定义时间格式</span>
<span class="keyword">type</span> CustomTime <span class="keyword">struct</span> {
    time.Time
}

<span class="function">func</span> (ct *CustomTime) <span class="function">UnmarshalJSON</span>(b []<span class="keyword">byte</span>) <span class="keyword">error</span> {
    s := <span class="keyword">string</span>(b)
    t, err := time.<span class="function">Parse</span>(<span class="string">"2006-01-02"</span>, s)
    <span class="keyword">if</span> err != <span class="keyword">nil</span> {
        <span class="keyword">return</span> err
    }
    ct.Time = t
    <span class="keyword">return</span> <span class="keyword">nil</span>
}</code></pre>
            
        </div>
    </div>
</body>
</html>