<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Go 语言学习教程</title>
    <link rel="stylesheet" href="styles.css?v=1.3">
</head>
<body>
    <div class="container">
        <aside class="sidebar">
        <!-- 导航栏将通过JavaScript动态加载 -->
    </aside>
        <div class="content">
            <h2>📊 Go 语言核心概念</h2>
            
            <h3>核心名词对照表</h3>
            <table>
                <caption>Go 语言核心概念</caption>
                <thead>
                    <tr>
                        <th>名词</th>
                        <th>英文名称</th>
                        <th>作用</th>
                        <th>示例</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Goroutine</strong></td>
                        <td>Goroutine</td>
                        <td>轻量级线程，由 Go 运行时管理</td>
                        <td><code>go func() {}()</code></td>
                    </tr>
                    <tr>
                        <td><strong>通道</strong></td>
                        <td>Channel</td>
                        <td>用于 goroutine 之间通信</td>
                        <td><code>ch := make(chan int)</code></td>
                    </tr>
                    <tr>
                        <td><strong>接口</strong></td>
                        <td>Interface</td>
                        <td>定义行为规范，实现多态</td>
                        <td><code>type Writer interface { Write(p []byte) (n int, err error) }</code></td>
                    </tr>
                    <tr>
                        <td><strong>结构体</strong></td>
                        <td>Struct</td>
                        <td>组合数据类型，类似类的概念</td>
                        <td><code>type User struct { Name string }</code></td>
                    </tr>
                    <tr>
                        <td><strong>指针</strong></td>
                        <td>Pointer</td>
                        <td>存储内存地址，直接操作数据</td>
                        <td><code>var p *int = &amp;n</code></td>
                    </tr>
                    <tr>
                        <td><strong>切片</strong></td>
                        <td>Slice</td>
                        <td>动态数组，可变长度</td>
                        <td><code>nums := []int{1, 2, 3}</code></td>
                    </tr>
                    <tr>
                        <td><strong>映射</strong></td>
                        <td>Map</td>
                        <td>键值对集合，哈希表</td>
                        <td><code>m := make(map[string]int)</code></td>
                    </tr>
                    <tr>
                        <td><strong>方法</strong></td>
                        <td>Method</td>
                        <td>绑定到类型的函数</td>
                        <td><code>func (u *User) GetName() string { return u.Name }</code></td>
                    </tr>
                    <tr>
                        <td><strong>包</strong></td>
                        <td>Package</td>
                        <td>代码组织单元，命名空间</td>
                        <td><code>package main</code></td>
                    </tr>
                    <tr>
                        <td><strong>模块</strong></td>
                        <td>Module</td>
                        <td>依赖管理单元，版本控制</td>
                        <td><code>go mod init example.com/mymodule</code></td>
                    </tr>
                </tbody>
            </table>

            <h3>Goroutine 调度模型（GMP）</h3>
            <div class="flowchart">
                <div class="flowchart-node">G (Goroutine)</div>
                <span class="flowchart-arrow">→</span>
                <div class="flowchart-node">P (Processor)</div>
                <span class="flowchart-arrow">→</span>
                <div class="flowchart-node">M (Machine/Thread)</div>
                <br><br>
                <div class="flowchart-node">本地运行队列</div>
                <span class="flowchart-arrow">↔</span>
                <div class="flowchart-node">全局运行队列</div>
                <span class="flowchart-arrow">↔</span>
                <div class="flowchart-node">工作窃取</div>
            </div>

            <div class="info-box">
                <h3>💡 GMP 模型说明</h3>
                <ul>
                    <li><strong>G (Goroutine)</strong>：Go 协程，用户态轻量级线程</li>
                    <li><strong>P (Processor)</strong>：处理器，每个 P 有一个本地运行队列</li>
                    <li><strong>M (Machine)</strong>：系统线程，负责执行 goroutine</li>
                    <li><strong>工作窃取</strong>：当 P 的本地队列为空时，从其他 P 窃取任务</li>
                </ul>
            </div>

            <h3>Channel（通道）</h3>
            <p>Channel 是 Go 语言中用于 goroutine 之间通信的核心机制，实现了 CSP（Communicating Sequential Processes）模型。</p>
            
            <table>
                <caption>Channel 类型与特性</caption>
                <thead>
                    <tr>
                        <th>类型</th>
                        <th>说明</th>
                        <th>示例</th>
                        <th>特性</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>无缓冲通道</strong></td>
                        <td>同步通信，发送和接收必须同时进行</td>
                        <td><code>ch := make(chan int)</code></td>
                        <td>阻塞式，保证数据传递</td>
                    </tr>
                    <tr>
                        <td><strong>有缓冲通道</strong></td>
                        <td>异步通信，缓冲区未满时不阻塞</td>
                        <td><code>ch := make(chan int, 10)</code></td>
                        <td>非阻塞式，提高吞吐量</td>
                    </tr>
                    <tr>
                        <td><strong>单向通道</strong></td>
                        <td>限制只能发送或接收</td>
                        <td><code>ch := make(chan<- int)</code></td>
                        <td>类型安全，防止误用</td>
                    </tr>
                    <tr>
                        <td><strong>Select 通道</strong></td>
                        <td>同时监听多个通道</td>
                        <td><code>select { case <-ch: }</code></td>
                        <td>多路复用，随机选择</td>
                    </tr>
                </tbody>
            </table>

            <div class="flowchart">
                <div class="flowchart-node">Goroutine A</div>
                <span class="flowchart-arrow">→</span>
                <div class="flowchart-node">发送数据到 Channel</div>
                <span class="flowchart-arrow">→</span>
                <div class="flowchart-node">Channel（缓冲区）</div>
                <span class="flowchart-arrow">→</span>
                <div class="flowchart-node">从 Channel 接收数据</div>
                <span class="flowchart-arrow">→</span>
                <div class="flowchart-node">Goroutine B</div>
            </div>

            <div class="info-box">
                <h3>💡 Channel 核心特性</h3>
                <ul>
                    <li><strong>线程安全</strong>：Channel 内部使用锁机制，保证并发安全</li>
                    <li><strong>阻塞机制</strong>：无缓冲通道会阻塞，直到有接收者</li>
                    <li><strong>关闭检测</strong>：可检测 channel 是否已关闭</li>
                    <li><strong>遍历通道</strong>：使用 range 遍历 channel 数据</li>
                </ul>
            </div>

            <h3>Context（上下文）</h3>
            <p>Context 是 Go 语言中用于控制 goroutine 生命周期、传递请求范围数据的机制。</p>

            <table>
                <caption>Context 类型与用途</caption>
                <thead>
                    <tr>
                        <th>类型</th>
                        <th>用途</th>
                        <th>示例</th>
                        <th>特点</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Background</strong></td>
                        <td>根上下文，永不取消</td>
                        <td><code>ctx := context.Background()</code></td>
                        <td>所有 context 的根节点</td>
                    </tr>
                    <tr>
                        <td><strong>TODO</strong></td>
                        <td>临时使用，不确定使用何种 context</td>
                        <td><code>ctx := context.TODO()</code></td>
                        <td>待优化时替换</td>
                    </tr>
                    <tr>
                        <td><strong>WithCancel</strong></td>
                        <td>可手动取消的 context</td>
                        <td><code>ctx, cancel := context.WithCancel(parent)</code></td>
                        <td>主动取消操作</td>
                    </tr>
                    <tr>
                        <td><strong>WithTimeout</strong></td>
                        <td>超时自动取消的 context</td>
                        <td><code>ctx, cancel := context.WithTimeout(parent, timeout)</code></td>
                        <td>防止长时间阻塞</td>
                    </tr>
                    <tr>
                        <td><strong>WithDeadline</strong></td>
                        <td>到截止时间自动取消</td>
                        <td><code>ctx, cancel := context.WithDeadline(parent, deadline)</code></td>
                        <td>指定截止时间</td>
                    </tr>
                    <tr>
                        <td><strong>WithValue</strong></td>
                        <td>携带键值对数据的 context</td>
                        <td><code>ctx := context.WithValue(parent, key, value)</code></td>
                        <td>传递请求范围数据</td>
                    </tr>
                </tbody>
            </table>

            <div class="flowchart">
                <div class="flowchart-node">Parent Context</div>
                <span class="flowchart-arrow">→</span>
                <div class="flowchart-node">创建 Child Context</div>
                <br><br>
                <div class="flowchart-node">WithCancel</div>
                <span class="flowchart-arrow">→</span>
                <div class="flowchart-node">手动调用 cancel()</div>
                <br>
                <div class="flowchart-node">WithTimeout</div>
                <span class="flowchart-arrow">→</span>
                <div class="flowchart-node">超时自动取消</div>
                <br>
                <div class="flowchart-node">WithValue</div>
                <span class="flowchart-arrow">→</span>
                <div class="flowchart-node">传递键值对数据</div>
            </div>

            <div class="warning-box">
                <h3>⚠️ Context 使用原则</h3>
                <ul>
                    <li><strong>不要在结构体中存储</strong>：Context 应该作为第一个参数传递</li>
                    <li><strong>不要设为可选参数</strong>：明确需要 context 时必须传递</li>
                    <li><strong>使用 nil 表示无上下文</strong>：不确定是否需要时传递 nil</li>
                    <li><strong>及时调用 cancel</strong>：避免资源泄漏</li>
                    <li><strong>只传递请求范围数据</strong>：不要使用 Context 传递可选参数</li>
                </ul>
            </div>

            <h3>Context 传播流程</h3>
            <div class="flowchart">
                <div class="flowchart-node">HTTP Request</div>
                <span class="flowchart-arrow">→</span>
                <div class="flowchart-node">创建 Root Context</div>
                <span class="flowchart-arrow">→</span>
                <div class="flowchart-node">WithTimeout 设置超时</div>
                <span class="flowchart-arrow">→</span>
                <div class="flowchart-node">传递给 Service 层</div>
                <span class="flowchart-arrow">→</span>
                <div class="flowchart-node">传递给 Database 层</div>
                <span class="flowchart-arrow">→</span>
                <div class="flowchart-node">超时或完成</div>
                <span class="flowchart-arrow">→</span>
                <div class="flowchart-node">自动取消所有子 Context</div>
            </div>

            <h3>函数迭代器（Function Iterator）</h3>
            <p>函数迭代器是 Go 语言中通过闭包实现的一种生成器模式，用于延迟计算和按需生成数据序列。</p>

            <table>
                <caption>迭代器类型与特点</caption>
                <thead>
                    <tr>
                        <th>类型</th>
                        <th>说明</th>
                        <th>示例</th>
                        <th>适用场景</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>数值迭代器</strong></td>
                        <td>生成连续数值序列</td>
                        <td><code>next := NewCounter(); next()</code></td>
                        <td>计数器、索引生成</td>
                    </tr>
                    <tr>
                        <td><strong>斐波那契迭代器</strong></td>
                        <td>生成斐波那契数列</td>
                        <td><code>next := NewFibonacci(); next()</code></td>
                        <td>数学计算、序列生成</td>
                    </tr>
                    <tr>
                        <td><strong>集合迭代器</strong></td>
                        <td>遍历集合元素</td>
                        <td><code>next := NewSliceIterator(s); next()</code></td>
                        <td>数据遍历、流式处理</td>
                    </tr>
                    <tr>
                        <td><strong>文件迭代器</strong></td>
                        <td>逐行读取文件</td>
                        <td><code>next := NewFileIterator(f); next()</code></td>
                        <td>大文件处理、日志分析</td>
                    </tr>
                    <tr>
                        <td><strong>数据库迭代器</strong></td>
                        <td>逐行读取查询结果</td>
                        <td><code>next := NewQueryIterator(); next()</code></td>
                        <td>大数据查询、分页处理</td>
                    </tr>
                </tbody>
            </table>

            <div class="flowchart">
                <div class="flowchart-node">调用迭代器函数</div>
                <span class="flowchart-arrow">→</span>
                <div class="flowchart-node">返回闭包函数</div>
                <span class="flowchart-arrow">→</span>
                <div class="flowchart-node">每次调用返回下一个值</div>
                <span class="flowchart-arrow">→</span>
                <div class="flowchart-node">内部状态自动更新</div>
                <span class="flowchart-arrow">→</span>
                <div class="flowchart-node">直到结束或取消</div>
            </div>

            <div class="info-box">
                <h3>💡 迭代器核心特性</h3>
                <ul>
                    <li><strong>延迟计算</strong>：只在需要时才计算下一个值，节省内存</li>
                    <li><strong>状态保持</strong>：闭包内部保存迭代状态</li>
                    <li><strong>无限序列</strong>：可以生成无限长的序列而不占用无限内存</li>
                    <li><strong>惰性求值</strong>：避免不必要的计算</li>
                    <li><strong>可组合</strong>：多个迭代器可以组合使用</li>
                </ul>
            </div>

            <div class="example-box">
                <h3>📝 迭代器实现示例</h3>
                <pre><code><span class="comment">// 数值迭代器</span>
<span class="keyword">func</span> <span class="function">NewCounter</span>() <span class="keyword">func</span>() <span class="keyword">int</span> {
    i := <span class="number">0</span>
    <span class="keyword">return</span> <span class="keyword">func</span>() <span class="keyword">int</span> {
        i++
        <span class="keyword">return</span> i
    }
}

<span class="comment">// 斐波那契迭代器</span>
<span class="keyword">func</span> <span class="function">NewFibonacci</span>() <span class="keyword">func</span>() <span class="keyword">int</span> {
    a, b := <span class="number">0</span>, <span class="number">1</span>
    <span class="keyword">return</span> <span class="keyword">func</span>() <span class="keyword">int</span> {
        a, b = b, a+b
        <span class="keyword">return</span> a
    }
}

<span class="comment">// 使用迭代器</span>
next := <span class="function">NewFibonacci</span>()
fmt.<span class="function">Println</span>(<span class="function">next</span>()) <span class="comment">// 1</span>
fmt.<span class="function">Println</span>(<span class="function">next</span>()) <span class="comment">// 1</span>
fmt.<span class="function">Println</span>(<span class="function">next</span>()) <span class="comment">// 2</span>
fmt.<span class="function">Println</span>(<span class="function">next</span>()) <span class="comment">// 3</span></code></pre>
            </div>

            <div class="warning-box">
                <h3>⚠️ 迭代器使用注意事项</h3>
                <ul>
                    <li><strong>避免共享状态</strong>：每个迭代器实例应该独立维护状态</li>
                    <li><strong>正确处理结束</strong>：检查迭代器是否已结束，避免无限循环</li>
                    <li><strong>资源清理</strong>：对于文件、数据库等资源，确保正确关闭</li>
                    <li><strong>并发安全</strong>：如果多个 goroutine 使用同一迭代器，需要加锁</li>
                    <li><strong>性能考虑</strong>：闭包调用有一定开销，性能敏感场景需评估</li>
                </ul>
            </div>

            <h3>迭代器 vs 切片</h3>
            <table class="comparison-table">
                <caption>迭代器与切片的对比</caption>
                <thead>
                    <tr>
                        <th>特性</th>
                        <th>迭代器</th>
                        <th>切片</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>内存占用</strong></td>
                        <td>O(1)，只保存当前状态</td>
                        <td>O(n)，需要存储所有元素</td>
                    </tr>
                    <tr>
                        <td><strong>计算方式</strong></td>
                        <td>延迟计算，按需生成</td>
                        <td>预先计算，存储结果</td>
                    </tr>
                    <tr>
                        <td><strong>序列长度</strong></td>
                        <td>可以是无限的</td>
                        <td>必须是有限的</td>
                    </tr>
                    <tr>
                        <td><strong>访问方式</strong></td>
                        <td>只能顺序访问</td>
                        <td>可以随机访问</td>
                    </tr>
                    <tr>
                        <td><strong>适用场景</strong></td>
                        <td>大数据流、无限序列</td>
                        <td>小数据集、需要随机访问</td>
                    </tr>
                </tbody>
            </table>

            <h3>泛型（Generics）</h3>
            <p>泛型是 Go 1.18 引入的重要特性，允许编写与类型无关的代码，提高代码复用性和类型安全性。</p>

            <table>
                <caption>泛型类型与用途</caption>
                <thead>
                    <tr>
                        <th>类型</th>
                        <th>说明</th>
                        <th>示例</th>
                        <th>适用场景</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>泛型函数</strong></td>
                        <td>函数接受任意类型参数</td>
                        <td><code>func Max[T comparable](a, b T) T</code></td>
                        <td>通用算法、工具函数</td>
                    </tr>
                    <tr>
                        <td><strong>泛型类型</strong></td>
                        <td>结构体或接口使用类型参数</td>
                        <td><code>type Stack[T any] struct { items []T }</code></td>
                        <td>数据结构、容器类型</td>
                    </tr>
                    <tr>
                        <td><strong>泛型方法</strong></td>
                        <td>泛型类型的方法</td>
                        <td><code>func (s *Stack[T]) Push(v T)</code></td>
                        <td>泛型类型的行为定义</td>
                    </tr>
                    <tr>
                        <td><strong>类型约束</strong></td>
                        <td>限制类型参数的范围</td>
                        <td><code>type Number interface { int | float64 }</code></td>
                        <td>确保类型参数满足要求</td>
                    </tr>
                    <tr>
                        <td><strong>类型推断</strong></td>
                        <td>编译器自动推断类型参数</td>
                        <td><code>Max(1, 2) // 自动推断为 int</code></td>
                        <td>简化泛型调用</td>
                    </tr>
                </tbody>
            </table>

            <div class="flowchart">
                <div class="flowchart-node">定义泛型函数</div>
                <span class="flowchart-arrow">→</span>
                <div class="flowchart-node">声明类型参数 [T]</div>
                <span class="flowchart-arrow">→</span>
                <div class="flowchart-node">添加类型约束</div>
                <span class="flowchart-arrow">→</span>
                <div class="flowchart-node">使用类型参数</div>
                <span class="flowchart-arrow">→</span>
                <div class="flowchart-node">编译器类型推断</div>
                <span class="flowchart-arrow">→</span>
                <div class="flowchart-node">生成具体类型代码</div>
            </div>

            <div class="info-box">
                <h3>💡 泛型核心特性</h3>
                <ul>
                    <li><strong>类型安全</strong>：编译时检查类型，避免运行时错误</li>
                    <li><strong>代码复用</strong>：编写一次代码，支持多种类型</li>
                    <li><strong>零性能开销</strong>：泛型在编译时实例化，无运行时开销</li>
                    <li><strong>类型推断</strong>：编译器可自动推断类型参数，简化调用</li>
                    <li><strong>约束系统</strong>：通过接口限制类型参数的使用范围</li>
                </ul>
            </div>

            <div class="example-box">
                <h3>📝 泛型实现示例</h3>
                <pre><code><span class="comment">// 泛型函数：找出两个值中较大的一个</span>
<span class="keyword">func</span> <span class="function">Max</span>[T <span class="keyword">comparable</span>](a, b T) T {
    <span class="keyword">if</span> a > b {
        <span class="keyword">return</span> a
    }
    <span class="keyword">return</span> b
}

<span class="comment">// 泛型类型：栈</span>
<span class="keyword">type</span> <span class="function">Stack</span>[T <span class="keyword">any</span>] <span class="keyword">struct</span> {
    items []T
}

<span class="keyword">func</span> (s *<span class="function">Stack</span>[T]) <span class="function">Push</span>(v T) {
    s.items = <span class="function">append</span>(s.items, v)
}

<span class="keyword">func</span> (s *<span class="function">Stack</span>[T]) <span class="function">Pop</span>() (T, <span class="keyword">bool</span>) {
    <span class="keyword">if</span> <span class="function">len</span>(s.items) == <span class="number">0</span> {
        <span class="keyword">var</span> zero T
        <span class="keyword">return</span> zero, <span class="keyword">false</span>
    }
    index := <span class="function">len</span>(s.items) - <span class="number">1</span>
    item := s.items[index]
    s.items = s.items[:index]
    <span class="keyword">return</span> item, <span class="keyword">true</span>
}

<span class="comment">// 类型约束：数值类型</span>
<span class="keyword">type</span> Number <span class="keyword">interface</span> {
    <span class="keyword">int</span> | <span class="keyword">int64</span> | <span class="keyword">float64</span>
}

<span class="comment">// 使用类型约束的泛型函数</span>
<span class="keyword">func</span> <span class="function">Sum</span>[T Number](values []T) T {
    <span class="keyword">var</span> total T
    <span class="keyword">for</span> _, v := <span class="keyword">range</span> values {
        total += v
    }
    <span class="keyword">return</span> total
}

<span class="comment">// 使用泛型</span>
s := <span class="function">NewStack</span>[<span class="keyword">string</span>]()
s.<span class="function">Push</span>(<span class="string">"Hello"</span>)
s.<span class="function">Push</span>(<span class="string">"World"</span>)

<span class="comment">// 类型推断</span>
<span class="function">Max</span>(<span class="number">1</span>, <span class="number">2</span>)          <span class="comment">// 自动推断为 int</span>
<span class="function">Max</span>(<span class="number">1.5</span>, <span class="number">2.5</span>)     <span class="comment">// 自动推断为 float64</span></code></pre>
            </div>

            <div class="warning-box">
                <h3>⚠️ 泛型使用注意事项</h3>
                <ul>
                    <li><strong>不要过度使用</strong>：泛型会增加代码复杂度，只在需要时使用</li>
                    <li><strong>合理使用约束</strong>：通过接口约束类型参数，提高类型安全性</li>
                    <li><strong>注意性能影响</strong>：泛型实例化会增加编译时间和二进制大小</li>
                    <li><strong>类型推断限制</strong>：某些情况下需要显式指定类型参数</li>
                    <li><strong>兼容性考虑</strong>：泛型是 Go 1.18+ 特性，注意版本兼容</li>
                </ul>
            </div>

            <h3>泛型 vs 接口</h3>
            <table class="comparison-table">
                <caption>泛型与接口的对比</caption>
                <thead>
                    <tr>
                        <th>特性</th>
                        <th>泛型</th>
                        <th>接口</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>类型安全</strong></td>
                        <td>编译时检查，完全类型安全</td>
                        <td>运行时检查，可能 panic</td>
                    </tr>
                    <tr>
                        <td><strong>性能</strong></td>
                        <td>零运行时开销</td>
                        <td>有接口调用开销</td>
                    </tr>
                    <tr>
                        <td><strong>代码复杂度</strong></td>
                        <td>增加代码复杂度</td>
                        <td>代码简洁</td>
                    </tr>
                    <tr>
                        <td><strong>适用场景</strong></td>
                        <td>容器、算法、数据结构</td>
                        <td>行为抽象、多态</td>
                    </tr>
                    <tr>
                        <td><strong>类型信息</strong></td>
                        <td>保留具体类型信息</td>
                        <td>丢失具体类型信息</td>
                    </tr>
                </tbody>
            </table>

            <h2>🎯 Go 语言应用场景</h2>
            
            <table>
                <caption>Go 语言主要应用场景</caption>
                <thead>
                    <tr>
                        <th>应用场景</th>
                        <th>典型项目</th>
                        <th>核心优势</th>
                        <th>技术栈</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Web 开发</strong></td>
                        <td>API 服务、Web 后端</td>
                        <td>高并发、低延迟、易部署</td>
                        <td>Gin、Echo、Fiber</td>
                    </tr>
                    <tr>
                        <td><strong>微服务架构</strong></td>
                        <td>分布式系统、微服务</td>
                        <td>轻量级、易扩展、容器化</td>
                        <td>gRPC、Go-Micro、Kratos</td>
                    </tr>
                    <tr>
                        <td><strong>云原生</strong></td>
                        <td>Docker、Kubernetes</td>
                        <td>系统级编程、性能优秀</td>
                        <td>containerd、CNI、CSI</td>
                    </tr>
                    <tr>
                        <td><strong>区块链</strong></td>
                        <td>以太坊、Hyperledger</td>
                        <td>高性能、安全性、并发处理</td>
                        <td>go-ethereum、Fabric</td>
                    </tr>
                    <tr>
                        <td><strong>命令行工具</strong></td>
                        <td>CLI 工具、DevOps 工具</td>
                        <td>单文件部署、跨平台</td>
                        <td>Cobra、Viper、urfave/cli</td>
                    </tr>
                    <tr>
                        <td><strong>网络编程</strong></td>
                        <td>代理、网关、中间件</td>
                        <td>高并发网络 I/O</td>
                        <td>net/http、net/rpc</td>
                    </tr>
                    <tr>
                        <td><strong>数据处理</strong></td>
                        <td>数据管道、ETL</td>
                        <td>高效处理、内存管理</td>
                        <td>Sonic、GoCarina/gocsv</td>
                    </tr>
                    <tr>
                        <td><strong>数据库</strong></td>
                        <td>分布式数据库、缓存</td>
                        <td>持久化、查询优化</td>
                        <td>TiDB、CockroachDB、BadgerDB</td>
                    </tr>
                </tbody>
            </table>

            </div>
    </div>
    <script src="navigation.js"></script>
<script src="code-collapse.js"></script>

</body>
</html>