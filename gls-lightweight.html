<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>轻量型 GLS - Go 教程</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="container">
        <div class="sidebar">
            <!-- 导航栏将通过JavaScript动态加载 -->
        </div>
        
        <div class="content">
            <h1>轻量型 GLS（Goroutine Local Storage）</h1>
            
            <p>Go 1.26 引入了轻量型的 Goroutine Local Storage（GLS），为每个 goroutine 提供了独立的存储空间。本文将详细介绍 GLS 的概念、使用场景、API 以及最佳实践。</p>
            
            <h2>什么是 GLS？</h2>
            
            <p>GLS（Goroutine Local Storage）是指为每个 goroutine 提供独立的存储空间，类似于线程本地存储（TLS）。每个 goroutine 可以访问和修改自己的数据，而不会影响其他 goroutine。</p>
            
            <h3>为什么需要 GLS？</h3>
            
            <ul>
                <li>避免在函数调用链中传递大量上下文参数</li>
                <li>简化请求追踪、日志记录等场景的实现</li>
                <li>提供更安全的替代方案来替代全局变量</li>
                <li>支持更灵活的上下文传播机制</li>
            </ul>
            
            <h2>基本用法</h2>
            
            <h3>1. 创建 GLS 存储区</h3>
            
            <pre><code><span class="keyword">package</span> main

<span class="keyword">import</span> (
    <span class="string">"fmt"</span>
    <span class="string">"runtime/gls"</span>
)

<span class="comment">// 定义一个 GLS 键</span>
<span class="keyword">var</span> requestIDKey = gls.<span class="function">NewKey</span>(<span class="string">"request-id"</span>)

<span class="function">func</span> <span class="function">main</span>() {
    <span class="comment">// 为当前 goroutine 设置值</span>
    gls.<span class="function">Set</span>(requestIDKey, <span class="string">"req-12345"</span>)
    
    <span class="comment">// 获取值</span>
    value := gls.<span class="function">Get</span>(requestIDKey)
    fmt.<span class="function">Println</span>(<span class="string">"Request ID:"</span>, value)  <span class="comment">// Output: Request ID: req-12345</span>
}</code></pre>
            
            <h3>2. 跨函数访问 GLS</h3>
            
            <pre><code><span class="keyword">package</span> main

<span class="keyword">import</span> (
    <span class="string">"fmt"</span>
    <span class="string">"runtime/gls"</span>
)

<span class="keyword">var</span> userIDKey = gls.<span class="function">NewKey</span>(<span class="string">"user-id"</span>)

<span class="function">func</span> <span class="function">processRequest</span>() {
    <span class="comment">// 在内部函数中访问 GLS</span>
    userID := gls.<span class="function">Get</span>(userIDKey)
    fmt.<span class="function">Println</span>(<span class="string">"Processing for user:"</span>, userID)
}

<span class="function">func</span> <span class="function">handleRequest</span>() {
    gls.<span class="function">Set</span>(userIDKey, <span class="string">"user-001"</span>)
    <span class="function">processRequest</span>()  <span class="comment">// 不需要传递 userID</span>
}

<span class="function">func</span> <span class="function">main</span>() {
    <span class="function">handleRequest</span>()
}</code></pre>
            
            <h3>3. 不同 Goroutine 独立存储</h3>
            
            <pre><code><span class="keyword">package</span> main

<span class="keyword">import</span> (
    <span class="string">"fmt"</span>
    <span class="string">"sync"</span>
    <span class="string">"runtime/gls"</span>
)

<span class="keyword">var</span> taskIDKey = gls.<span class="function">NewKey</span>(<span class="string">"task-id"</span>)

<span class="function">func</span> <span class="function">worker</span>(id <span class="keyword">int</span>, wg *sync.WaitGroup) {
    <span class="keyword">defer</span> wg.<span class="function">Done</span>()
    
    <span class="comment">// 每个 goroutine 有自己独立的值</span>
    gls.<span class="function">Set</span>(taskIDKey, fmt.<span class="function">Sprintf</span>(<span class="string">"task-%d"</span>, id))
    
    fmt.<span class="function">Println</span>(<span class="string">"Worker"</span>, id, <span class="string">"task:"</span>, gls.<span class="function">Get</span>(taskIDKey))
}

<span class="function">func</span> <span class="function">main</span>() {
    <span class="keyword">var</span> wg sync.WaitGroup
    
    <span class="keyword">for</span> i := 0; i < 3; i++ {
        wg.<span class="function">Add</span>(1)
        <span class="keyword">go</span> <span class="function">worker</span>(i, &wg)
    }
    
    wg.<span class="function">Wait</span>()
}</code></pre>
            
            <h2>API 详解</h2>
            
            <h3>gls.NewKey</h3>
            <p>创建一个新的 GLS 键，用于标识存储的值。</p>
            
            <pre><code><span class="keyword">func</span> <span class="function">NewKey</span>(name <span class="keyword">string</span>) *Key</code></pre>
            
            <pre><code><span class="keyword">package</span> main

<span class="keyword">import</span> <span class="string">"runtime/gls"</span>

<span class="keyword">var</span> (
    userIDKey   = gls.<span class="function">NewKey</span>(<span class="string">"user-id"</span>)
    traceIDKey  = gls.<span class="function">NewKey</span>(<span class="string">"trace-id"</span>)
    sessionKey  = gls.<span class="function">NewKey</span>(<span class="string">"session"</span>)
)</code></pre>
            
            <h3>gls.Set</h3>
            <p>为当前 goroutine 设置键值对。</p>
            
            <pre><code><span class="keyword">func</span> <span class="function">Set</span>(key *Key, value <span class="keyword">interface</span>{})</code></pre>
            
            <pre><code><span class="keyword">package</span> main

<span class="keyword">import</span> (
    <span class="string">"fmt"</span>
    <span class="string">"runtime/gls"</span>
)

<span class="keyword">var</span> contextKey = gls.<span class="function">NewKey</span>(<span class="string">"context"</span>)

<span class="function">func</span> <span class="function">main</span>() {
    <span class="comment">// 设置简单值</span>
    gls.<span class="function">Set</span>(contextKey, <span class="string">"request-context"</span>)
    
    <span class="comment">// 设置复杂值</span>
    gls.<span class="function">Set</span>(contextKey, <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>{
        <span class="string">"user"</span>: <span class="string">"alice"</span>,
        <span class="string">"role"</span>: <span class="string">"admin"</span>,
    })
    
    fmt.<span class="function">Println</span>(gls.<span class="function">Get</span>(contextKey))
}</code></pre>
            
            <h3>gls.Get</h3>
            <p>获取当前 goroutine 中键对应的值。</p>
            
            <pre><code><span class="keyword">func</span> <span class="function">Get</span>(key *Key) <span class="keyword">interface</span>{}</code></pre>
            
            <pre><code><span class="keyword">package</span> main

<span class="keyword">import</span> (
    <span class="string">"fmt"</span>
    <span class="string">"runtime/gls"</span>
)

<span class="keyword">var</span> counterKey = gls.<span class="function">NewKey</span>(<span class="string">"counter"</span>)

<span class="function">func</span> <span class="function">increment</span>() {
    <span class="keyword">var</span> count <span class="keyword">int</span>
    <span class="keyword">if</span> val := gls.<span class="function">Get</span>(counterKey); val != <span class="keyword">nil</span> {
        count = val.(<span class="keyword">int</span>)
    }
    count++
    gls.<span class="function">Set</span>(counterKey, count)
}

<span class="function">func</span> <span class="function">main</span>() {
    <span class="function">increment</span>()
    <span class="function">increment</span>()
    fmt.<span class="function">Println</span>(<span class="string">"Count:"</span>, gls.<span class="function">Get</span>(counterKey))  <span class="comment">// Output: Count: 2</span>
}</code></pre>
            
            <h3>gls.Delete</h3>
            <p>删除当前 goroutine 中的键值对。</p>
            
            <pre><code><span class="keyword">func</span> <span class="function">Delete</span>(key *Key)</code></pre>
            
            <pre><code><span class="keyword">package</span> main

<span class="keyword">import</span> (
    <span class="string">"fmt"</span>
    <span class="string">"runtime/gls"</span>
)

<span class="keyword">var</span> tempKey = gls.<span class="function">NewKey</span>(<span class="string">"temp"</span>)

<span class="function">func</span> <span class="function">main</span>() {
    gls.<span class="function">Set</span>(tempKey, <span class="string">"temporary data"</span>)
    fmt.<span class="function">Println</span>(<span class="string">"Before delete:"</span>, gls.<span class="function">Get</span>(tempKey))
    
    gls.<span class="function">Delete</span>(tempKey)
    fmt.<span class="function">Println</span>(<span class="string">"After delete:"</span>, gls.<span class="function">Get</span>(tempKey))  <span class="comment">// Output: After delete: &lt;nil&gt;</span>
}</code></pre>
            
            <h3>gls.Clear</h3>
            <p>清除当前 goroutine 的所有 GLS 数据。</p>
            
            <pre><code><span class="keyword">func</span> <span class="function">Clear</span>()</code></pre>
            
            <pre><code><span class="keyword">package</span> main

<span class="keyword">import</span> (
    <span class="string">"fmt"</span>
    <span class="string">"runtime/gls"</span>
)

<span class="keyword">var</span> (
    key1 = gls.<span class="function">NewKey</span>(<span class="string">"key1"</span>)
    key2 = gls.<span class="function">NewKey</span>(<span class="string">"key2"</span>)
    key3 = gls.<span class="function">NewKey</span>(<span class="string">"key3"</span>)
)

<span class="function">func</span> <span class="function">main</span>() {
    gls.<span class="function">Set</span>(key1, <span class="string">"value1"</span>)
    gls.<span class="function">Set</span>(key2, <span class="string">"value2"</span>)
    gls.<span class="function">Set</span>(key3, <span class="string">"value3"</span>)
    
    fmt.<span class="function">Println</span>(<span class="string">"Before clear:"</span>, gls.<span class="function">Get</span>(key1), gls.<span class="function">Get</span>(key2), gls.<span class="function">Get</span>(key3))
    
    gls.<span class="function">Clear</span>()
    
    fmt.<span class="function">Println</span>(<span class="string">"After clear:"</span>, gls.<span class="function">Get</span>(key1), gls.<span class="function">Get</span>(key2), gls.<span class="function">Get</span>(key3))
}</code></pre>
            
            <h3>gls.With</h3>
            <p>在函数作用域内临时设置 GLS 值，函数返回后自动恢复。</p>
            
            <pre><code><span class="keyword">func</span> <span class="function">With</span>(key *Key, value <span class="keyword">interface</span>{}, f <span class="function">func</span>())</code></pre>
            
            <pre><code><span class="keyword">package</span> main

<span class="keyword">import</span> (
    <span class="string">"fmt"</span>
    <span class="string">"runtime/gls"</span>
)

<span class="keyword">var</span> operationKey = gls.<span class="function">NewKey</span>(<span class="string">"operation"</span>)

<span class="function">func</span> <span class="function">doWork</span>() {
    fmt.<span class="function">Println</span>(<span class="string">"Current operation:"</span>, gls.<span class="function">Get</span>(operationKey))
}

<span class="function">func</span> <span class="function">main</span>() {
    gls.<span class="function">Set</span>(operationKey, <span class="string">"main"</span>)
    
    <span class="function">doWork</span>()  <span class="comment">// Output: Current operation: main</span>
    
    <span class="comment">// 临时修改操作名称</span>
    gls.<span class="function">With</span>(operationKey, <span class="string">"temporary"</span>, <span class="function">func</span>() {
        <span class="function">doWork</span>()  <span class="comment">// Output: Current operation: temporary</span>
    })
    
    <span class="function">doWork</span>()  <span class="comment">// Output: Current operation: main (已恢复)</span>
}</code></pre>
            
            <h3>gls.Range</h3>
            <p>遍历当前 goroutine 的所有 GLS 键值对。</p>
            
            <pre><code><span class="keyword">func</span> <span class="function">Range</span>(f <span class="function">func</span>(key *Key, value <span class="keyword">interface</span>{}) <span class="keyword">bool</span>)</code></pre>
            
            <pre><code><span class="keyword">package</span> main

<span class="keyword">import</span> (
    <span class="string">"fmt"</span>
    <span class="string">"runtime/gls"</span>
)

<span class="keyword">var</span> (
    nameKey  = gls.<span class="function">NewKey</span>(<span class="string">"name"</span>)
    ageKey   = gls.<span class="function">NewKey</span>(<span class="string">"age"</span>)
    emailKey = gls.<span class="function">NewKey</span>(<span class="string">"email"</span>)
)

<span class="function">func</span> <span class="function">main</span>() {
    gls.<span class="function">Set</span>(nameKey, <span class="string">"Alice"</span>)
    gls.<span class="function">Set</span>(ageKey, 30)
    gls.<span class="function">Set</span>(emailKey, <span class="string">"alice@example.com"</span>)
    
    fmt.<span class="function">Println</span>(<span class="string">"All GLS values:"</span>)
    gls.<span class="function">Range</span>(<span class="function">func</span>(key *Key, value <span class="keyword">interface</span>{}) <span class="keyword">bool</span> {
        fmt.<span class="function">Printf</span>(<span class="string">"  %s: %v\n"</span>, key.<span class="function">Name</span>(), value)
        <span class="keyword">return</span> <span class="keyword">true</span>
    })
}</code></pre>
            
            <h2>实际应用场景</h2>
            
            <h3>1. 请求追踪（Request Tracing）</h3>
            <p>在 Web 请求处理中追踪请求 ID，方便日志关联和调试。</p>
            
            <pre><code><span class="keyword">package</span> main

<span class="keyword">import</span> (
    <span class="string">"fmt"</span>
    <span class="string">"log"</span>
    <span class="string">"runtime/gls"</span>
)

<span class="keyword">var</span> traceIDKey = gls.<span class="function">NewKey</span>(<span class="string">"trace-id"</span>)

<span class="function">func</span> <span class="function">logWithTrace</span>(message <span class="keyword">string</span>) {
    traceID := gls.<span class="function">Get</span>(traceIDKey)
    log.<span class="function">Printf</span>(<span class="string">"[%s] %s\n"</span>, traceID, message)
}

<span class="function">func</span> <span class="function">processRequest</span>() {
    <span class="function">logWithTrace</span>(<span class="string">"Processing request"</span>)
    <span class="function">logWithTrace</span>(<span class="string">"Validating input"</span>)
    <span class="function">logWithTrace</span>(<span class="string">"Processing complete"</span>)
}

<span class="function">func</span> <span class="function">handleRequest</span>(traceID <span class="keyword">string</span>) {
    gls.<span class="function">Set</span>(traceIDKey, traceID)
    <span class="function">processRequest</span>()
}

<span class="function">func</span> <span class="function">main</span>() {
    <span class="function">handleRequest</span>(<span class="string">"trace-12345"</span>)
}</code></pre>
            
            <h3>2. 用户上下文管理</h3>
            <p>在微服务架构中传递用户信息，避免在每个函数中传递参数。</p>
            
            <pre><code><span class="keyword">package</span> main

<span class="keyword">import</span> (
    <span class="string">"fmt"</span>
    <span class="string">"runtime/gls"</span>
)

<span class="keyword">type</span> UserContext <span class="keyword">struct</span> {
    UserID   <span class="keyword">string</span>
    Username <span class="keyword">string</span>
    Role     <span class="keyword">string</span>
}

<span class="keyword">var</span> userContextKey = gls.<span class="function">NewKey</span>(<span class="string">"user-context"</span>)

<span class="function">func</span> <span class="function">getCurrentUser</span>() *UserContext {
    <span class="keyword">if</span> val := gls.<span class="function">Get</span>(userContextKey); val != <span class="keyword">nil</span> {
        <span class="keyword">return</span> val.(*UserContext)
    }
    <span class="keyword">return</span> <span class="keyword">nil</span>
}

<span class="function">func</span> <span class="function">checkPermission</span>(resource <span class="keyword">string</span>) <span class="keyword">bool</span> {
    user := <span class="function">getCurrentUser</span>()
    <span class="keyword">if</span> user == <span class="keyword">nil</span> {
        <span class="keyword">return</span> <span class="keyword">false</span>
    }
    
    <span class="keyword">if</span> user.Role == <span class="string">"admin"</span> {
        <span class="keyword">return</span> <span class="keyword">true</span>
    }
    
    <span class="comment">// 其他权限检查逻辑</span>
    <span class="keyword">return</span> <span class="keyword">false</span>
}

<span class="function">func</span> <span class="function">accessResource</span>(resource <span class="keyword">string</span>) {
    <span class="keyword">if</span> <span class="function">checkPermission</span>(resource) {
        fmt.<span class="function">Printf</span>(<span class="string">"User %s can access %s\n"</span>, 
            <span class="function">getCurrentUser</span>().Username, resource)
    } <span class="keyword">else</span> {
        fmt.<span class="function">Println</span>(<span class="string">"Access denied"</span>)
    }
}

<span class="function">func</span> <span class="function">main</span>() {
    user := &UserContext{
        UserID:   <span class="string">"user-001"</span>,
        Username: <span class="string">"alice"</span>,
        Role:     <span class="string">"admin"</span>,
    }
    
    gls.<span class="function">Set</span>(userContextKey, user)
    <span class="function">accessResource</span>(<span class="string">"secret-data"</span>)
}</code></pre>
            
            <h3>3. 数据库连接管理</h3>
            <p>为每个请求提供独立的数据库连接，避免连接混淆。</p>
            
            <pre><code><span class="keyword">package</span> main

<span class="keyword">import</span> (
    <span class="string">"fmt"</span>
    <span class="string">"runtime/gls"</span>
)

<span class="keyword">type</span> DBConnection <span class="keyword">struct</span> {
    ID     <span class="keyword">string</span>
    Active <span class="keyword">bool</span>
}

<span class="keyword">var</span> dbConnectionKey = gls.<span class="function">NewKey</span>(<span class="string">"db-connection"</span>)

<span class="function">func</span> <span class="function">getDBConnection</span>() *DBConnection {
    <span class="keyword">if</span> val := gls.<span class="function">Get</span>(dbConnectionKey); val != <span class="keyword">nil</span> {
        <span class="keyword">return</span> val.(*DBConnection)
    }
    
    <span class="comment">// 创建新连接</span>
    conn := &DBConnection{
        ID:     fmt.<span class="function">Sprintf</span>(<span class="string">"conn-%d"</span>, gls.<span class="function">GoroutineID</span>()),
        Active: <span class="keyword">true</span>,
    }
    gls.<span class="function">Set</span>(dbConnectionKey, conn)
    <span class="keyword">return</span> conn
}

<span class="function">func</span> <span class="function">queryData</span>() {
    conn := <span class="function">getDBConnection</span>()
    fmt.<span class="function">Printf</span>(<span class="string">"Querying with connection: %s\n"</span>, conn.ID)
}

<span class="function">func</span> <span class="function">main</span>() {
    <span class="function">queryData</span>()
}</code></pre>
            
            <h3>4. 错误处理和恢复</h3>
            <p>在错误处理中保留上下文信息，便于错误追踪。</p>
            
            <pre><code><span class="keyword">package</span> main

<span class="keyword">import</span> (
    <span class="string">"fmt"</span>
    <span class="string">"runtime/gls"</span>
)

<span class="keyword">var</span> operationKey = gls.<span class="function">NewKey</span>(<span class="string">"operation"</span>)

<span class="function">func</span> <span class="function">safeExecute</span>(operation <span class="keyword">string</span>, f <span class="function">func</span>()) {
    gls.<span class="function">With</span>(operationKey, operation, <span class="function">func</span>() {
        <span class="keyword">defer</span> <span class="function">func</span>() {
            <span class="keyword">if</span> r := <span class="function">recover</span>(); r != <span class="keyword">nil</span> {
                op := gls.<span class="function">Get</span>(operationKey)
                fmt.<span class="function">Printf</span>(<span class="string">"Panic in operation '%s': %v\n"</span>, op, r)
            }
        }()
        f()
    })
}

<span class="function">func</span> <span class="function">riskyOperation</span>() {
    <span class="function">panic</span>(<span class="string">"something went wrong"</span>)
}

<span class="function">func</span> <span class="function">main</span>() {
    <span class="function">safeExecute</span>(<span class="string">"data-processing"</span>, riskyOperation)
}</code></pre>
            
            <h3>5. 配置覆盖</h3>
            <p>在测试或特定场景中临时覆盖配置。</p>
            
            <pre><code><span class="keyword">package</span> main

<span class="keyword">import</span> (
    <span class="string">"fmt"</span>
    <span class="string">"runtime/gls"</span>
)

<span class="keyword">var</span> configKey = gls.<span class="function">NewKey</span>(<span class="string">"config"</span>)

<span class="keyword">type</span> Config <span class="keyword">struct</span> {
    Debug <span class="keyword">bool</span>
    MaxRetries <span class="keyword">int</span>
}

<span class="function">func</span> <span class="function">getConfig</span>() *Config {
    <span class="keyword">if</span> val := gls.<span class="function">Get</span>(configKey); val != <span class="keyword">nil</span> {
        <span class="keyword">return</span> val.(*Config)
    }
    <span class="comment">// 返回默认配置</span>
    <span class="keyword">return</span> &Config{Debug: <span class="keyword">false</span>, MaxRetries: 3}
}

<span class="function">func</span> <span class="function">doOperation</span>() {
    config := <span class="function">getConfig</span>()
    fmt.<span class="Function">Printf</span>(<span class="string">"Debug: %v, MaxRetries: %d\n"</span>, config.Debug, config.MaxRetries)
}

<span class="function">func</span> <span class="function">main</span>() {
    <span class="comment">// 使用默认配置</span>
    <span class="function">doOperation</span>()
    
    <span class="comment">// 临时使用测试配置</span>
    testConfig := &Config{Debug: <span class="keyword">true</span>, MaxRetries: 1}
    gls.<span class="function">With</span>(configKey, testConfig, <span class="function">func</span>() {
        <span class="function">doOperation</span>()
    })
    
    <span class="comment">// 恢复默认配置</span>
    <span class="function">doOperation</span>()
}</code></pre>
            
            <h2>最佳实践</h2>
            
            <h3>1. 避免滥用</h3>
            <p>GLS 应该谨慎使用，不要过度依赖。它适用于特定的场景，如请求追踪、上下文传递等。</p>
            
            <h3>2. 明确键的命名</h3>
            <p>使用清晰、唯一的键名，避免冲突。</p>
            
            <pre><code><span class="comment">// 好的做法</span>
<span class="keyword">var</span> requestTraceIDKey = gls.<span class="function">NewKey</span>(<span class="string">"request-trace-id"</span>)
<span class="keyword">var</span> userAuthenticationTokenKey = gls.<span class="function">NewKey</span>(<span class="string">"user-auth-token"</span>)

<span class="comment">// 不好的做法</span>
<span class="keyword">var</span> key1 = gls.<span class="function">NewKey</span>(<span class="string">"k1"</span>)
<span class="keyword">var</span> key2 = gls.<span class="function">NewKey</span>(<span class="string">"k2"</span>)</code></pre>
            
            <h3>3. 及时清理</h3>
            <p>在使用完毕后及时清理 GLS 数据，避免内存泄漏。</p>
            
            <pre><code><span class="keyword">func</span> <span class="function">processRequest</span>() {
    gls.<span class="function">Set</span>(traceIDKey, traceID)
    <span class="keyword">defer</span> gls.<span class="function">Delete</span>(traceIDKey)
    
    <span class="comment">// 处理请求</span>
}</code></pre>
            
            <h3>4. 类型安全</h3>
            <p>使用类型断言时要小心，确保类型安全。</p>
            
            <pre><code><span class="keyword">func</span> <span class="function">getUserName</span>() <span class="keyword">string</span> {
    val := gls.<span class="function">Get</span>(userNameKey)
    <span class="keyword">if</span> val == <span class="keyword">nil</span> {
        <span class="keyword">return</span> <span class="string">""</span>
    }
    
    <span class="keyword">if</span> name, ok := val.(<span class="keyword">string</span>); ok {
        <span class="keyword">return</span> name
    }
    
    <span class="keyword">return</span> <span class="string">""</span>
}</code></pre>
            
            <h3>5. 文档说明</h3>
            <p>在使用 GLS 的代码中添加文档说明，帮助其他开发者理解。</p>
            
            <pre><code><span class="comment">// processUser 处理用户请求。
//
// 此函数依赖 GLS 存储用户上下文信息：
//   - user-context: 用户上下文对象，包含用户 ID 和角色
//
// 必须在调用此函数之前通过 gls.Set 设置用户上下文。</span></code></pre>
            
            <h3>6. 考虑 Context 作为替代</h3>
            <p>在某些场景下，使用 context.Context 可能是更好的选择。</p>
            
            <pre><code><span class="comment">// 使用 Context</span>
<span class="keyword">func</span> <span class="function">processWithContext</span>(ctx context.Context) {
    userID := ctx.<span class="function">Value</span>(<span class="string">"user-id"</span>).(<span class="keyword">string</span>)
    <span class="comment">// 处理逻辑</span>
}

<span class="comment">// 使用 GLS</span>
<span class="keyword">func</span> <span class="function">processWithGLS</span>() {
    userID := gls.<span class="function">Get</span>(userIDKey).(<span class="keyword">string</span>)
    <span class="comment">// 处理逻辑</span>
}</code></pre>
            
            <h2>性能考虑</h2>
            
            <h3>1. 内存开销</h3>
            <p>GLS 的实现非常轻量，每个 goroutine 的存储开销很小。但仍然应该避免存储大量数据。</p>
            
            <h3>2. 访问速度</h3>
            <p>GLS 的访问速度非常快，接近于普通变量访问。但在性能关键路径上，应该进行基准测试。</p>
            
            <pre><code><span class="keyword">package</span> main

<span class="keyword">import</span> (
    <span class="string">"runtime/gls"</span>
    <span class="string">"testing"</span>
)

<span class="keyword">var</span> testKey = gls.<span class="function">NewKey</span>(<span class="string">"test"</span>)

<span class="function">func</span> <span class="function">BenchmarkGLSGet</span>(b *testing.B) {
    gls.<span class="function">Set</span>(testKey, <span class="string">"value"</span>)
    b.<span class="function">ResetTimer</span>()
    
    <span class="keyword">for</span> i := 0; i < b.N; i++ {
        _ = gls.<span class="function">Get</span>(testKey)
    }
}</code></pre>
            
            <h3>3. 与 Context 的对比</h3>
            
            <ul>
                <li><strong>GLS</strong>：访问更快，但只能在当前 goroutine 内使用</li>
                <li><strong>Context</strong>：可以跨 goroutine 传递，但需要显式传递参数</li>
            </ul>
            
            <h2>限制和注意事项</h2>
            
            <h3>1. Goroutine 生命周期</h3>
            <p>GLS 数据与 goroutine 绑定，goroutine 结束后数据会被自动清理。</p>
            
            <h3>2. 跨 Goroutine 访问</h3>
            <p>GLS 数据不能跨 goroutine 访问，每个 goroutine 有自己独立的存储空间。</p>
            
            <pre><code><span class="keyword">func</span> <span class="function">main</span>() {
    gls.<span class="function">Set</span>(key, <span class="string">"main-value"</span>)
    
    <span class="keyword">go</span> <span class="function">func</span>() {
        <span class="comment">// 这里获取不到 main goroutine 的值</span>
        fmt.<span class="function">Println</span>(gls.<span class="function">Get</span>(key))  <span class="comment">// Output: &lt;nil&gt;</span>
    }()
}</code></pre>
            
            <h3>3. 与 Go Context 的关系</h3>
            <p>GLS 和 Context 是互补的机制，应该根据场景选择使用。</p>
            
            <h2>总结</h2>
            
            <p>Go 1.26 引入的轻量型 GLS 为开发者提供了一个强大而灵活的工具，用于管理 goroutine 级别的存储。通过合理使用 GLS，可以：</p>
            
            <ul>
                <li>简化代码，减少参数传递</li>
                <li>提高代码可读性和可维护性</li>
                <li>更好地管理请求上下文和追踪信息</li>
                <li>实现更灵活的错误处理和恢复机制</li>
            </ul>
            
            <p>但同时也要注意，GLS 应该谨慎使用，避免滥用导致代码难以理解和维护。在实际应用中，应该根据具体场景选择最合适的方案。</p>
        </div>
    </div>
    
    <script src="navigation.js"></script>
    <script src="code-collapse.js"></script>
</body>
</html>