<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>sync 并发原语 - Go 学习教程</title>
    <link rel="stylesheet" href="styles.css?v=1.3">
    </head>
<body>
    <div class="container">
        <aside class="sidebar">
        <!-- 导航栏将通过JavaScript动态加载 -->
    </aside>
                <div class="content">
            <a href="stdlib.html" class="back-link">← 返回 stdlib</a>
            <h2 id="sync">sync 并发原语</h2>

            <h3>Mutex 互斥锁</h3>
            <pre><code><span class="keyword">package</span> main

<span class="keyword">import</span> (
    <span class="string">"fmt"</span>
    <span class="string">"sync"</span>
)

<span class="keyword">type</span> Counter <span class="keyword">struct</span> {
    mu    sync.Mutex
    value <span class="keyword">int</span>
}

<span class="function">func</span> (c *Counter) <span class="function">Increment</span>() {
    c.mu.<span class="function">Lock</span>()
    <span class="keyword">defer</span> c.mu.<span class="function">Unlock</span>()
    c.value++
}

<span class="function">func</span> (c *Counter) <span class="function">Value</span>() <span class="keyword">int</span> {
    c.mu.<span class="function">Lock</span>()
    <span class="keyword">defer</span> c.mu.<span class="function">Unlock</span>()
    <span class="keyword">return</span> c.value
}

<span class="function">func</span> <span class="function">main</span>() {
    <span class="keyword">var</span> counter Counter
    <span class="keyword">var</span> wg sync.WaitGroup
    
    <span class="keyword">for</span> i := <span class="number">0</span>; i < <span class="number">1000</span>; i++ {
        wg.<span class="function">Add</span>(<span class="number">1</span>)
        <span class="keyword">go</span> <span class="keyword">func</span>() {
            <span class="keyword">defer</span> wg.<span class="function">Done</span>()
            counter.<span class="function">Increment</span>()
        }()
    }
    
    wg.<span class="function">Wait</span>()
    fmt.<span class="function">Println</span>(<span class="string">"Final value:"</span>, counter.<span class="function">Value</span>())
}</code></pre>

            <h3>RWMutex 读写锁</h3>
            <pre><code><span class="keyword">package</span> main

<span class="keyword">import</span> (
    <span class="string">"fmt"</span>
    <span class="string">"sync"</span>
    <span class="string">"time"</span>
)

<span class="keyword">type</span> Cache <span class="keyword">struct</span> {
    mu    sync.RWMutex
    data  <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>
}

<span class="function">func</span> <span class="function">NewCache</span>() *Cache {
    <span class="keyword">return</span> &Cache{
        data: <span class="function">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>),
    }
}

<span class="function">func</span> (c *Cache) <span class="function">Get</span>(key <span class="keyword">string</span>) (<span class="keyword">string</span>, <span class="keyword">bool</span>) {
    c.mu.<span class="function">RLock</span>()
    <span class="keyword">defer</span> c.mu.<span class="function">RUnlock</span>()
    val, ok := c.data[key]
    <span class="keyword">return</span> val, ok
}

<span class="function">func</span> (c *Cache) <span class="function">Set</span>(key, value <span class="keyword">string</span>) {
    c.mu.<span class="function">Lock</span>()
    <span class="keyword">defer</span> c.mu.<span class="function">Unlock</span>()
    c.data[key] = value
}

<span class="function">func</span> <span class="function">main</span>() {
    cache := <span class="function">NewCache</span>()
    <span class="keyword">var</span> wg sync.WaitGroup
    
    <span class="comment">// 写入</span>
    <span class="keyword">for</span> i := <span class="number">0</span>; i < <span class="number">10</span>; i++ {
        wg.<span class="function">Add</span>(<span class="number">1</span>)
        <span class="keyword">go</span> <span class="keyword">func</span>(i <span class="keyword">int</span>) {
            <span class="keyword">defer</span> wg.<span class="function">Done</span>()
            key := fmt.<span class="function">Sprintf</span>(<span class="string">"key%d"</span>, i)
            value := fmt.<span class="function">Sprintf</span>(<span class="string">"value%d"</span>, i)
            cache.<span class="function">Set</span>(key, value)
        }(i)
    }
    
    <span class="comment">// 读取</span>
    <span class="keyword">for</span> i := <span class="number">0</span>; i < <span class="number">10</span>; i++ {
        wg.<span class="function">Add</span>(<span class="number">1</span>)
        <span class="keyword">go</span> <span class="keyword">func</span>(i <span class="keyword">int</span>) {
            <span class="keyword">defer</span> wg.<span class="function">Done</span>()
            key := fmt.<span class="function">Sprintf</span>(<span class="string">"key%d"</span>, i)
            time.<span class="function">Sleep</span>(time.Millisecond)
            val, ok := cache.<span class="function">Get</span>(key)
            fmt.<span class="function">Printf</span>(<span class="string">"Get %s: %v, %v\n"</span>, key, val, ok)
        }(i)
    }
    
    wg.<span class="function">Wait</span>()
}</code></pre>

            <h3>WaitGroup 等待组</h3>
            <pre><code><span class="keyword">package</span> main

<span class="keyword">import</span> (
    <span class="string">"fmt"</span>
    <span class="string">"sync"</span>
)

<span class="function">func</span> <span class="function">worker</span>(id <span class="keyword">int</span>, wg *sync.WaitGroup) {
    <span class="keyword">defer</span> wg.<span class="function">Done</span>()
    fmt.<span class="function">Printf</span>(<span class="string">"Worker %d started\n"</span>, id)
    fmt.<span class="function">Printf</span>(<span class="string">"Worker %d finished\n"</span>, id)
}

<span class="function">func</span> <span class="function">main</span>() {
    <span class="keyword">var</span> wg sync.WaitGroup
    
    <span class="keyword">for</span> i := <span class="number">1</span>; i <= <span class="number">5</span>; i++ {
        wg.<span class="function">Add</span>(<span class="number">1</span>)
        <span class="keyword">go</span> <span class="function">worker</span>(i, &wg)
    }
    
    wg.<span class="function">Wait</span>()
    fmt.<span class="function">Println</span>(<span class="string">"All workers finished"</span>)
}</code></pre>

            <h3>Once 单次执行</h3>
            <pre><code><span class="keyword">package</span> main

<span class="keyword">import</span> (
    <span class="string">"fmt"</span>
    <span class="string">"sync"</span>
)

<span class="keyword">var</span> (
    once     sync.Once
    instance *Singleton
)

<span class="keyword">type</span> Singleton <span class="keyword">struct</span> {
    value <span class="keyword">string</span>
}

<span class="function">func</span> <span class="function">GetInstance</span>() *Singleton {
    once.<span class="function">Do</span>(<span class="keyword">func</span>() {
        instance = &Singleton{value: <span class="string">"initialized"</span>}
        fmt.<span class="function">Println</span>(<span class="string">"Singleton initialized"</span>)
    })
    <span class="keyword">return</span> instance
}

<span class="function">func</span> <span class="function">main</span>() {
    <span class="comment">// 多次调用只会初始化一次</span>
    <span class="function">GetInstance</span>()
    <span class="function">GetInstance</span>()
    <span class="function">GetInstance</span>()
}</code></pre>

            <h3>Cond 条件变量</h3>
            <pre><code><span class="keyword">package</span> main

<span class="keyword">import</span> (
    <span class="string">"fmt"</span>
    <span class="string">"sync"</span>
    <span class="string">"time"</span>
)

<span class="function">func</span> <span class="function">main</span>() {
    <span class="keyword">var</span> mu sync.Mutex
    cond := sync.<span class="function">NewCond</span>(&mu)
    ready := <span class="keyword">false</span>
    
    <span class="comment">// 等待者</span>
    <span class="keyword">go</span> <span class="keyword">func</span>() {
        mu.<span class="function">Lock</span>()
        <span class="keyword">for</span> !ready {
            fmt.<span class="function">Println</span>(<span class="string">"Waiting..."</span>)
            cond.<span class="function">Wait</span>()
        }
        fmt.<span class="function">Println</span>(<span class="string">"Ready!"</span>)
        mu.<span class="function">Unlock</span>()
    }()
    
    time.<span class="function">Sleep</span>(time.Second)
    
    <span class="comment">// 通知者</span>
    mu.<span class="function">Lock</span>()
    ready = <span class="keyword">true</span>
    fmt.<span class="function">Println</span>(<span class="string">"Signaling..."</span>)
    cond.<span class="function">Signal</span>()
    mu.<span class="function">Unlock</span>()
    
    time.<span class="function">Sleep</span>(time.Second)
}</code></pre>

            <h3>Pool 对象池</h3>
            <pre><code><span class="keyword">package</span> main

<span class="keyword">import</span> (
    <span class="string">"bytes"</span>
    <span class="string">"fmt"</span>
    <span class="string">"sync"</span>
)

<span class="keyword">var</span> bufferPool = sync.<span class="function">Pool</span>{
    New: <span class="keyword">func</span>() <span class="keyword">interface</span>{} {
        fmt.<span class="function">Println</span>(<span class="string">"Creating new buffer"</span>)
        <span class="keyword">return</span> &bytes.Buffer{}
    },
}

<span class="function">func</span> <span class="function">process</span>() {
    <span class="comment">// 从池中获取</span>
    buf := bufferPool.<span class="function">Get</span>().(*bytes.Buffer)
    <span class="keyword">defer</span> <span class="keyword">func</span>() {
        <span class="comment">// 重置并放回池中</span>
        buf.<span class="function">Reset</span>()
        bufferPool.<span class="function">Put</span>(buf)
    }()
    
    buf.<span class="function">WriteString</span>(<span class="string">"Hello, World!"</span>)
    fmt.<span class="function">Println</span>(<span class="string">"Buffer:"</span>, buf.<span class="function">String</span>())
}

<span class="function">func</span> <span class="function">main</span>() {
    <span class="keyword">for</span> i := <span class="number">0</span>; i < <span class="number">5</span>; i++ {
        <span class="function">process</span>()
    }
}</code></pre>

            <h3>Map 并发安全映射</h3>
            <pre><code><span class="keyword">package</span> main

<span class="keyword">import</span> (
    <span class="string">"fmt"</span>
    <span class="string">"sync"</span>
)

<span class="function">func</span> <span class="function">main</span>() {
    <span class="keyword">var</span> m sync.Map
    
    <span class="comment">// 存储</span>
    m.<span class="function">Store</span>(<span class="string">"key1"</span>, <span class="string">"value1"</span>)
    m.<span class="function">Store</span>(<span class="string">"key2"</span>, <span class="string">"value2"</span>)
    
    <span class="comment">// 加载</span>
    <span class="keyword">if</span> val, ok := m.<span class="function">Load</span>(<span class="string">"key1"</span>); ok {
        fmt.<span class="function">Println</span>(<span class="string">"key1:"</span>, val)
    }
    
    <span class="comment">// 加载或存储</span>
    actual, loaded := m.<span class="function">LoadOrStore</span>(<span class="string">"key3"</span>, <span class="string">"value3"</span>)
    fmt.<span class="function">Printf</span>(<span class="string">"key3: %v, loaded: %v\n"</span>, actual, loaded)
    
    <span class="comment">// 遍历</span>
    m.<span class="function">Range</span>(<span class="keyword">func</span>(key, value <span class="keyword">interface</span>{}) <span class="keyword">bool</span> {
        fmt.<span class="function">Printf</span>(<span class="string">"%s: %s\n"</span>, key, value)
        <span class="keyword">return</span> <span class="keyword">true</span>
    })
    
    <span class="comment">// 删除</span>
    m.<span class="function">Delete</span>(<span class="string">"key1"</span>)
}</code></pre>

            <h3>Atomic 原子操作</h3>
            <pre><code><span class="keyword">package</span> main

<span class="keyword">import</span> (
    <span class="string">"fmt"</span>
    <span class="string">"sync/atomic"</span>
)

<span class="function">func</span> <span class="function">main</span>() {
    <span class="keyword">var</span> counter int64
    
    <span class="comment">// 原子增加</span>
    atomic.<span class="function">AddInt64</span>(&counter, <span class="number">1</span>)
    fmt.<span class="function">Println</span>(<span class="string">"Counter:"</span>, counter)
    
    <span class="comment">// 原子加载</span>
    value := atomic.<span class="function">LoadInt64</span>(&counter)
    fmt.<span class="function">Println</span>(<span class="string">"Loaded:"</span>, value)
    
    <span class="comment">// 原子存储</span>
    atomic.<span class="function">StoreInt64</span>(&counter, <span class="number">100</span>)
    fmt.<span class="function">Println</span>(<span class="string">"Stored:"</span>, atomic.<span class="function">LoadInt64</span>(&counter))
    
    <span class="comment">// 原子比较并交换</span>
    swapped := atomic.<span class="function">CompareAndSwapInt64</span>(&counter, <span class="number">100</span>, <span class="number">200</span>)
    fmt.<span class="function">Printf</span>(<span class="string">"Swapped: %v, Value: %d\n"</span>, swapped, atomic.<span class="function">LoadInt64</span>(&counter))
}</code></pre>

            
        </div>
    </div>
</body>
    <script src="navigation.js"></script>
</html>